<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Run London Run</title>
    <!-- Favicon fix -->
    <link rel="icon" href="https://fav.farm/ðŸ›ï¸" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap");

      body {
        margin: 0;
        overflow: hidden;
        font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
        background: #000;
        touch-action: none; /* FIX FOR MOBILE SCROLLING */
        overflow: hidden;
      }
      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
        overflow: hidden;
      }

      /* UI Layer */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        flex-direction: column;
        justify-content: flex-end; /* Align to bottom */
        align-items: center;
        padding-bottom: 160px; /* Increased from 80px to raise it up */
        box-sizing: border-box;
        z-index: 20;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0) 0%,
          rgba(0, 0, 0, 0.4) 100%
        );
      }

      #loading-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 50;
        pointer-events: auto;
      }
      #loading-screen.hidden {
        pointer-events: none !important;
      }

      .hidden {
        opacity: 0;
        pointer-events: none;
      }

      /* HUD - Minimal, Right-Aligned */
      #game-hud {
        position: absolute;
        top: 20px;
        right: 20px;
        background: transparent;
        padding: 15px;
        color: white;
        display: none;
        z-index: 10;
        text-align: right;
      }

      .hud-label {
        font-size: 0.65rem;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 5px;
        letter-spacing: 1px;
        font-weight: 400;
      }
      .hud-value {
        font-size: 2rem;
        font-weight: 700;
        color: #fff;
        letter-spacing: 0px;
        font-family: "Inter", sans-serif;
      }

      /* Minimalist HUD */
      #stamina-container {
        position: fixed;
        bottom: 40px;
        right: 40px;
        width: 250px;
        text-align: right;
        z-index: 10;
        display: none; /* Removed as requested */
      }

      .hud-label {
        font-size: 0.75rem;
        color: #888;
        letter-spacing: 2px;
        margin-bottom: 4px;
        font-weight: 500;
      }

      .hud-value {
        font-size: 2.5rem;
        color: #fff;
        font-weight: 300; 
        letter-spacing: -1px;
        margin: 0;
        line-height: 1;
      }

      #stamina-bar-bg {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.15);
        margin-top: 10px;
        border-radius: 2px;
        overflow: hidden;
      }

      #stamina-bar-fill {
        height: 100%;
        width: 100%;
        background: #fff;
        transform-origin: left;
        transition: transform 0.1s linear;
      }

      /* Start Screen - INSTITUTIONAL STYLE */
      .title {
        font-family: "Inter", sans-serif;
        font-size: 4rem;
        color: #fff;
        font-weight: 300;
        margin-bottom: 2rem;
        text-transform: uppercase;
        letter-spacing: 4px;
        text-align: center;
        /* Removed gradient text fill for solid institutional white */
      }

      .subtitle {
        font-size: 1.2rem;
        color: #ccc;
        margin-bottom: 3rem;
        font-weight: 400;
        font-family: "Inter", sans-serif;
        letter-spacing: 2px;
        text-transform: uppercase;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px 30px;
        border-radius: 4px;
        border: 1px solid rgba(255,255,255,0.1);
      }

      .btn {
        pointer-events: auto;
        background: #fff;
        color: #000;
        padding: 15px 40px;
        font-family: "Inter", sans-serif;
        font-weight: 700;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        transition: all 0.2s ease;
        position: relative;
        z-index: 100;
        touch-action: manipulation;
      }

      .btn:hover {
        background: #ccc;
        transform: translateY(-2px);
      }

      /* --- THIEF MARKER --- */
      #thief-marker {
        position: absolute;
        z-index: 15;
        pointer-events: none;
        display: none;
        transform: translate(-50%, -50%);
      }
      .marker-dot {
        width: 10px;
        height: 10px;
        background: #fff;
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255,255,255,0.5);
      }
      .marker-label {
        display: none; /* Hide label for cleaner look */
      }

      /* --- END SCREEN (Professional Card) --- */
      #end-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(15px);
        z-index: 30;
      }

      .end-card {
        background: rgba(20, 20, 25, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 50px 60px;
        border-radius: 24px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        transform: scale(0.9);
        opacity: 0;
        animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        max-width: 500px;
        width: 90%;
      }

      @keyframes popIn {
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      #end-title {
        font-size: 2.5rem;
        margin: 0 0 10px 0;
        text-transform: uppercase;
        letter-spacing: -1px;
        line-height: 1;
      }

      #end-msg {
        font-size: 1.1rem;
        color: #aab;
        margin-bottom: 30px;
        line-height: 1.5;
      }

      .btn {
        padding: 12px 30px; /* Reduced padding */
        font-size: 0.9rem; /* Reduced font size */
        background: #fff;
        color: #000;
        border: none;
        border-radius: 4px; /* Sharp corners or slight radius */
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
        font-family: "Inter", sans-serif;
        outline: none;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      }
      .btn:hover {
        transform: translateY(-2px);
        background: #ddd;
        box-shadow: 0 6px 15px rgba(0,0,0,0.4);
      }
      .btn:active {
        transform: translateY(1px);
      }

      /* --- IN-GAME ALERTS --- */
      #phone-overlay {
        position: absolute;
        bottom: -20px; /* Visible at bottom */
        right: 40px;
        width: 250px;
        height: 400px;
        background: #111;
        border: 4px solid #333;
        border-radius: 30px;
        z-index: 5;
        transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        display: flex; /* Visible initially */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      }
      #phone-screen {
        width: 90%;
        height: 92%;
        background: #fff;
        color: #333;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: sans-serif;
        font-size: 0.8rem;
        text-align: center;
        overflow: hidden;
        position: relative;
        border-radius: 24px;
      }

      #alert-msg {
        position: absolute;
        top: 25%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff3333;
        font-size: 2rem;
        font-weight: 800;
        font-family: "Inter", sans-serif;
        display: none;
        z-index: 15;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 4px;
        background: rgba(0,0,0,0.8);
        padding: 20px 40px;
        border: 1px solid rgba(255,50,50,0.3);
      }
      /* Remove pulse/bounce animations for professional look, or make them subtle */
      @keyframes pulse { from { opacity: 0.8; } to { opacity: 1; } }
      @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

      #controls-hint {
        position: absolute;
        bottom: 30px;
        left: 30px;
        color: rgba(255, 255, 255, 0.8);
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(5px);
        padding: 12px 20px;
        border-radius: 50px;
        font-size: 0.8rem;
        pointer-events: none;
        user-select: none;
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-weight: 600;
      }
      b {
        color: #fff;
      }

      /* --- MOBILE CONTROLS --- */
      #mobile-controls {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
        display: none; /* Shown via JS */
      }
      #joystick-container {
        position: absolute;
        bottom: 40px;
        left: 40px;
        width: 120px;
        height: 120px;
        pointer-events: auto;
        user-select: none;
        touch-action: none;
      }
      #joystick-outer {
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }
      #joystick-inner {
        width: 50px;
        height: 50px;
        background: #EAEAEA;
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        transition: transform 0.1s ease-out;
        pointer-events: none;
      }
      #action-buttons {
        position: absolute;
        bottom: 40px;
        right: 40px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        pointer-events: auto;
      }
      .mobile-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.8);
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(5px);
        color: #fff;
        font-family: "Inter", sans-serif;
        font-weight: 700;
        font-size: 0.8rem;
        letter-spacing: 1px;
        outline: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        transition: all 0.1s ease;
        pointer-events: auto;
        cursor: pointer;
      }
      .mobile-btn:active {
        background: #fff;
        color: #000;
        transform: scale(0.9);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
      }
      #sprint-btn.active {
        background: #fff;
        color: #000;
        border-color: #fff;
      }

      /* NARRATIVE SEQUENCE STYLES */
      #narrative-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        opacity: 0;
        visibility: hidden;
        transition: opacity 3s ease;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding-top: 0; /* use absolute positioning for children instead */
        color: white;
        text-align: center;
        padding-left: 40px;
        padding-right: 40px;
        box-sizing: border-box;
      }
      .case-status-card {
        background: #fff;
        color: #000;
        padding: 60px 80px;
        border-radius: 2px;
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        text-transform: none; /* Sentence case */
        letter-spacing: 2px;
        font-weight: 300;
        opacity: 0;
        transform: translateY(10px);
        transition: all 1.2s cubic-bezier(0.2, 0.8, 0.2, 1);
        text-align: center; /* Forced center */
        border: 1px solid rgba(255,255,255,0.1);
      }
      .case-status-card.show {
        opacity: 1;
        transform: translateY(0);
      }
      .case-status-label {
        font-size: 0.7rem;
        color: #888;
        margin-bottom: 5px;
        font-weight: 400;
      }
      .case-status-value {
        font-size: 2.2rem;
        font-weight: 700;
        color: #000;
        margin-top: 10px;
      }
      .narrative-text {
        font-family: 'Helvetica Neue', Arial, sans-serif;
        max-width: 1000px; /* Increased from 700px */
        font-size: 1.6rem; /* Reduced from 2.2rem */
        line-height: 1.4;
        font-weight: 300;
        opacity: 0;
        transition: opacity 2s ease;
        position: absolute;
        top: 50%; /* Vertical Center */
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        text-align: center;
      }
      .narrative-text b {
        font-weight: 700;
        color: #fff;
      }
      #chart-slide, #story-slide {
        display: none;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 1000px; /* Increased from 800px */
        opacity: 0;
        transition: opacity 2s ease;
        position: absolute;
        top: 50%; /* Vertical Center */
        left: 50%;
        transform: translate(-50%, -50%);
      }
      #chart-slide h2 {
        font-family: 'Helvetica Neue', Helvetica, sans-serif;
        font-size: 1.6rem; /* Reduced from 2.2rem */
        font-weight: 300;
        margin-bottom: 10px;
        text-align: center;
        letter-spacing: -0.02em;
      }
      canvas#theft-chart {
        max-height: 380px !important;
        margin-top: 10px;
      }
      .story-form {
        text-align: center; /* Forced Center */
        width: 100%;
        max-width: 900px; /* Increased width */
      }
      .story-form h1 {
        font-family: 'Helvetica Neue', Helvetica, sans-serif;
        font-weight: 300;
        font-size: 1.8rem; /* Reduced from 2.5rem */
        margin: 0 0 10px 0;
        letter-spacing: -0.02em;
      }
      .story-form p {
        font-size: 0.85rem; /* Reduced from 1rem */
        color: #ccc;
        font-weight: 300;
        margin-bottom: 30px;
      }
      .story-form label {
        display: block;
        font-size: 1rem;
        text-transform: none; /* Sentence case explicitly */
        letter-spacing: 1px;
        color: #ccc;
        margin-bottom: 15px;
      }
      .story-form textarea {
        width: 100%;
        height: 250px; /* Increased writing area */
        background: rgba(255,255,255,0.03); /* Subtle background */
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 0;
        color: white;
        padding: 20px;
        font-family: 'Helvetica Neue', sans-serif;
        font-size: 1.1rem; /* Reduced from 1.5rem */
        margin-bottom: 30px;
        resize: none;
        outline: none;
        transition: border-color 0.3s;
      }
      .story-form textarea:focus {
        border-color: rgba(255,255,255,0.4);
      }
      .story-footer {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 30px;
        width: 100%;
      }
      
      .share-btn {
        background: #fff;
        color: #000;
        padding: 15px 30px;
        border: none;
        font-family: 'Inter', sans-serif;
        font-weight: 600;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 100%;
      }
      
      .share-btn:hover {
        background: #ddd;
      }
      
      .share-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .exit-link {
        font-size: 0.7rem;
        color: #444;
        text-decoration: none;
        text-transform: uppercase;
        letter-spacing: 2px;
        cursor: pointer;
        transition: color 0.3s;
      }
      .exit-link:hover {
        color: #888;
      }

      /* --- MOBILE RESPONSIVENESS --- */
      @media (max-width: 768px) {
        /* Narrative Text - Significantly Reduced */
        .narrative-text {
          font-size: 0.85rem !important;
          line-height: 1.5 !important;
          padding: 0 20px !important;
          max-width: 90% !important;
          top: 45% !important;
        }
        
        /* Case Status UI */
        #case-status-ui {
          padding: 20px !important;
        }
        #case-status-ui .case-status-value {
          font-size: 1.8rem !important;
          margin-bottom: 8px !important;
        }
        #case-status-ui .case-status-label {
          font-size: 0.65rem !important;
        }
        
        /* Story Form */
        .story-form {
          max-width: 90% !important;
          padding: 25px !important;
        }
        .story-form h1 {
          font-size: 1.2rem !important;
          margin-bottom: 10px !important;
        }
        .story-form p {
          font-size: 0.7rem !important;
          line-height: 1.4 !important;
          margin-bottom: 15px !important;
        }
        .story-form label {
          font-size: 0.75rem !important;
          margin-bottom: 6px !important;
        }
        .story-form textarea {
          font-size: 0.85rem !important;
          height: 150px !important;
          padding: 12px !important;
        }
        .share-btn {
          font-size: 0.8rem !important;
          padding: 10px 24px !important;
        }
        .exit-link {
          font-size: 0.6rem !important;
        }
        
        /* Loading Screen */
        #intro-disclaimer {
          font-size: 0.8rem !important;
          padding: 0 20px !important;
        }
        #loading-text {
          font-size: 1.2rem !important;
        }
        #loading-subtext {
          font-size: 0.65rem !important;
          margin-top: 15px !important;
        }
        
        /* Start Button */
        .btn {
          padding: 12px 28px !important;
          font-size: 0.85rem !important;
        }
      }

      /* --- ROTATION PROMPT FOR MOBILE/TABLET --- */
      #rotation-prompt {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 99999;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-family: 'Helvetica Neue', sans-serif;
      }
      #rotation-prompt .rotate-icon {
        font-size: 4rem;
        margin-bottom: 20px;
        animation: rotateAnim 2s infinite ease-in-out;
      }
      #rotation-prompt p {
        font-size: 1rem;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #888;
      }
      @keyframes rotateAnim {
        0%, 100% { transform: rotate(0deg); }
        50% { transform: rotate(90deg); }
      }
      
      
      /* Show rotation prompt only on mobile/tablet in portrait AND during gameplay */
      @media (max-width: 1024px) and (orientation: portrait) {
        body.game-active #rotation-prompt {
          display: flex !important;
        }
      }

      /* --- EXTRA SMALL PHONES (< 480px) --- */
      @media (max-width: 480px) {
        /* Story Form - Top aligned on mobile to prevent cutoff */
        #story-slide {
          top: 0 !important;
          transform: translate(-50%, 0) !important;
          padding-top: 20px;
          max-height: 100vh;
          overflow-y: auto;
        }
        
        /* Narrative overlay scrollable */
        #narrative-overlay {
          overflow-y: auto;
        }
        
        /* Phone Overlay - Smaller */
        #phone-overlay {
          width: 150px !important;
          height: 240px !important;
          bottom: -20px !important;
          right: 20px !important;
        }
        
        /* HUD - Smaller */
        #game-hud {
          top: 10px !important;
          right: 10px !important;
          padding: 10px !important;
        }
        .hud-label {
          font-size: 0.5rem !important;
        }
        .hud-value {
          font-size: 1.5rem !important;
        }
        
        /* Narrative Text - Even Smaller for Phones */
        .narrative-text {
          font-size: 0.65rem !important;
          line-height: 1.35 !important;
          padding: 0 12px !important;
        }
        
        /* Case Status UI */
        #case-status-ui .case-status-value {
          font-size: 1.3rem !important;
        }
        #case-status-ui .case-status-label {
          font-size: 0.5rem !important;
        }
        
        /* Story Form */
        .story-form {
          padding: 18px !important;
        }
        .story-form h1 {
          font-size: 0.95rem !important;
        }
        .story-form p {
          font-size: 0.55rem !important;
          line-height: 1.3 !important;
        }
        .story-form label {
          font-size: 0.6rem !important;
        }
        .story-form textarea {
          font-size: 0.7rem !important;
          height: 120px !important;
        }
        .share-btn {
          font-size: 0.65rem !important;
          padding: 7px 18px !important;
        }
        
        /* Loading Screen */
        #intro-disclaimer {
          font-size: 0.65rem !important;
        }
        #loading-text {
          font-size: 0.95rem !important;
        }
        #loading-subtext {
          font-size: 0.5rem !important;
        }
        
        /* CRITICAL: Ensure start button is clickable on phones */
        #start-btn {
          z-index: 10000 !important;
          pointer-events: auto !important;
          touch-action: manipulation !important;
          -webkit-tap-highlight-color: rgba(255, 255, 255, 0.3) !important;
          min-width: 200px !important;
          min-height: 44px !important;
          position: relative !important;
        }
        
        /* Ensure UI layer doesn't block */
        #ui-layer {
          pointer-events: none !important;
        }
        #ui-layer > * {
          pointer-events: auto;
        }
      }
    </style>
  </head>
  <body>
    <!-- Rotation Prompt -->
    <div id="rotation-prompt">
      <div class="rotate-icon">ðŸ“±</div>
      <p>Please rotate your device</p>
    </div>
    <!-- Start Screen -->
    <div id="ui-layer">
      <!-- Simple Percent Loader -->
      <div id="loading-screen" style="display: flex; justify-content: center; align-items: center; background: #000; flex-direction: column; width: 100%; height: 100%; position: absolute; top: 0; left: 0;">
          <div id="intro-disclaimer" style="font-family: 'Helvetica Neue', sans-serif; font-size: 1.3rem; color: #888; letter-spacing: 3px; text-transform: uppercase; font-weight: 300; opacity: 0; transition: opacity 2s ease; text-align: center; padding: 20px; max-width: 90%;">
              Based on thousands of true incidents
          </div>
          <div id="loading-text" style="font-family: 'Inter', monospace; font-weight: 300; font-size: 1.5rem; letter-spacing: 2px; color: #fff; text-align: center; opacity: 0; transition: opacity 1s ease;">
            0%
            <div id="loading-subtext" style="font-size: 1rem; color: #999; margin-top: 25px; letter-spacing: 1px; min-height: 30px; line-height: 1.6; font-family: 'Helvetica Neue', sans-serif; opacity: 0; transition: opacity 0.5s ease; text-align: center;"></div>
          </div>
      </div>

      <!-- Start Button (Hidden Initially) -->
      <button class="btn" id="start-btn" style="display: none; opacity: 0; transition: opacity 1s ease;">Start Experience</button>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
      <div id="joystick-container">
        <div id="joystick-outer">
          <div id="joystick-inner"></div>
        </div>
      </div>
      <div id="action-buttons">
        <button id="sprint-btn" class="mobile-btn">SPRINT</button>
      </div>
    </div>

    <!-- Thief Marker -->
    <div id="thief-marker">
        <div class="marker-dot"></div>
    </div>

    <!-- HUD -->
    <div id="game-hud">
      <div class="hud-label">DISTANCE TO TARGET</div>
      <div class="hud-value" id="dist-val" style="color: #ff4444">0m</div>
    </div>

    <!-- End Screen (Professional Card) -->
    <div id="end-screen">
      <div id="end-card-container" style="transition: opacity 2s ease;">
          <div class="end-card">
            <h1 id="end-title">GAME OVER</h1>
            <p id="end-msg">What happened?</p>
            <div
              id="restart-area"
              style="
                margin-top: 20px;
                padding-top: 20px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
              "
            >
              <button class="btn" onclick="location.reload()">Play Again</button>
            </div>
          </div>
      </div>
    </div>

    <!-- Narrative Sequence -->
    <div id="narrative-overlay">
       <div id="case-status-ui" class="case-status-card" style="text-align: center; padding: 60px 80px;">
          <div class="case-status-label" style="font-size: 0.8rem; letter-spacing: 4px; margin-bottom: 15px;">CASE STATUS:</div>
          <div class="case-status-value" style="font-size: 2.8rem; margin: 0; line-height: 1;">NO FURTHER ACTION</div>
       </div>
       
       <div id="nar-slide-1" class="narrative-text">
          This experience is not rare.
       </div>
       
       <div id="nar-slide-2" class="narrative-text">
          According to official police-recorded figures in England and Wales, mobile phone theft remains a significant issue. 
          In the year ending March 2024, an estimated <b>78,000 incidents</b> of phones or bags being snatched on the street were reported, 
          equivalent to roughly <b>200 snatch-theft offences per day</b>.
          <br><br>
          Recorded counts of mobile phones stolen from 2019 to March 2025 show a sharp rise over the period, 
          from 91,481 thefts in 2019 to <b>117,211 in 2024</b>.
       </div>



    <!-- Question Slide (New) -->
    <div id="question-slide" style="display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 900px; opacity: 0; transition: opacity 2s ease; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
      <h2 style="font-family: 'Helvetica Neue', Helvetica, sans-serif; font-size: 1.8rem; font-weight: 300; margin-bottom: 40px; color: #fff;">
        Have you experienced phone theft in London?
      </h2>
      <div style="display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 400px; margin: 0 auto;">
        <button class="share-btn" onclick="handleQuestionAnswer('yes')">Yes</button>
        <button class="share-btn" onclick="handleQuestionAnswer('someone')">Not me, but someone I know</button>
        <button class="share-btn" onclick="handleQuestionAnswer('no')">No</button>
      </div>
    </div>

       <div id="story-slide">
          <div class="story-form">
              <h1>Whatâ€™s your story?</h1>
              <p>If this has happened to you, you may add your experience.<br>Your story will be represented in the game as a non-interactive figure.</p>
              
              <label>What happened after you reported it?</label>
              <textarea placeholder="Write here..."></textarea>
              
              <div class="story-footer">
                  <button class="share-btn" onclick="submitStory()">Share story</button>
                  <a class="exit-link" onclick="showCredits()">Exit</a>
              </div>
          </div>
       </div>

       <!-- Confirmation Slide -->
       <div id="confirmation-slide" style="display: none; opacity: 0; transition: opacity 2s ease;">
          <div class="story-form" style="text-align: center;">
              <h1 style="font-size: 1.5rem; margin-bottom: 30px;">Your story added to system</h1>
              <p style="color: #666; font-size: 0.9rem; margin-bottom: 40px;">Thank you for sharing your experience.</p>
              <button class="share-btn" onclick="showCredits()" style="margin-top: 20px;">Continue</button>
          </div>
       </div>

       <!-- Credits Slide -->
       <div id="credits-slide" style="display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; background: #000; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 2s ease; z-index: 200;">
          <div class="story-form" style="text-align: center;">
              <p style="color: #666; font-size: 0.75rem; letter-spacing: 3px; text-transform: uppercase; margin-bottom: 30px;">Created by</p>
              <h1 style="font-size: 2rem; font-weight: 300; margin-bottom: 20px; color: #fff;">Rahulraj P V</h1>
              <p style="color: #888; font-size: 0.9rem; margin-bottom: 10px; font-family: 'Helvetica Neue', sans-serif;">University of the Arts London</p>
              <p style="color: #555; font-size: 0.8rem; margin-top: 40px; margin-bottom: 50px;">Music & Sound Assets<br>Epidemic Sound / Freesound</p>
              
              <button class="exit-link" onclick="window.location.reload()" style="font-size: 0.9rem; border: 1px solid #333; padding: 10px 30px; border-radius: 4px;">RETURN TO START</button>
          </div>
       </div>
    </div>

    <!-- Phone UI -->
    <div id="phone-overlay">
      <div id="phone-screen">
        <div style="padding: 15px; width: 100%; height: 100%; display: flex; flex-direction: column; box-sizing: border-box;">
          <div
            style="
              display: flex;
              justify-content: space-between;
              margin-bottom: 20px;
              color: #aaa;
              font-size: 10px;
              font-weight: bold;
              width: 100%;
            "
          >
            <span>9:41</span><span>5G</span>
          </div>
          
          <!-- SENT MESSAGE -->
          <div
            style="
              align-self: flex-end;
              width: fit-content;
              max-width: 80%;
              background: #e1ffc7;
              padding: 10px 14px;
              border-radius: 15px 15px 2px 15px;
              margin-bottom: 8px;
              text-align: right;
              box-shadow: 0 1px 2px rgba(0,0,0,0.1);
              color: #333;
            "
          >
            On my way!
          </div>

          <!-- RECEIVED MESSAGE -->
          <div
            style="
              align-self: flex-start;
              width: fit-content;
              max-width: 80%;
              background: #f0f0f0;
              padding: 10px 14px;
              border-radius: 15px 15px 15px 2px;
              margin-bottom: 8px;
              text-align: left;
              box-shadow: 0 1px 2px rgba(0,0,0,0.1);
              color: #333;
            "
          >
            Meet at South Bank?
          </div>

          <!-- TYPING INDICATOR -->
          <div
            style="
              align-self: flex-start;
              margin-top: auto; /* Push to bottom or just below messages? Keeping it below messages. */
              margin-top: 10px;
              font-weight: bold;
              color: #ccc;
              font-size: 0.7rem;
              font-style: italic;
            "
          >
            Typing...
          </div>
        </div>
      </div>
    </div>

    <div id="alert-msg">
      PHONE STOLEN!<br /><span
        style="font-size: 1.5rem; color: white; font-weight: 400"
        >CHASE THE TARGET</span
      >
    </div>

    <div id="controls-hint">
      <b>WASD</b> MOVE &nbsp;&nbsp; <b>SHIFT</b> SPRINT &nbsp;&nbsp;
      <b>SPACE</b> JUMP
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <!-- Post Processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Environment Shaders -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Sky.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Lensflare.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FilmShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/FilmPass.js"></script>
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
      // --- Configuration & Globals ---
      let camera, scene, renderer, controls;
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;
      let isSprinting = false;
      let walkSound, runSound; // New global audio objects

      let prevTime = performance.now();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();

      // Game Logic Globals
      let gameStarted = false;
      let phoneSnatched = false;
      let snatchActive = false; // New flag to prevent early fail
      let gameEnded = false;
      let canBeCaught = false;
      let snatcherMesh;
      let snatcherSpeed = 0;

      // Stamina Logic
      let stamina = 100;
      const maxStamina = 100;
      const sprintCost = 35;
      const regenRate = 15;

      // --- Time of Day Configurations ---
      const TimePresets = {
        Morning: {
          sky: {
            turbidity: 2,
            rayleigh: 1.5,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            elevation: 15,
            azimuth: 180,
          },
          light: {
            ambient: 0xddeeff,
            ground: 0x888888,
            dirColor: 0xfffaed,
            dirIntensity: 4.0,
            dirPos: [-100, 100, -50],
          },
          fog: { color: 0xddeeff, density: 0.002 },
          env: {
            exposure: 0.6,
            bloomStrength: 0.4,
            bloomThreshold: 0.9,
            sunColor: 0xfffaed,
          },
        },
        Day: {
          sky: {
            turbidity: 1,
            rayleigh: 0.5,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            elevation: 60,
            azimuth: 180,
          },
          light: {
            ambient: 0xffffff,
            ground: 0xccccff,
            dirColor: 0xffffee,
            dirIntensity: 5.0,
            dirPos: [-50, 200, 50],
          },
          fog: { color: 0xeef7ff, density: 0.001 },
          env: {
            exposure: 0.8,
            bloomStrength: 0.3,
            bloomThreshold: 0.95,
            sunColor: 0xffffee,
          },
        },
        Evening: {
          sky: {
            turbidity: 10,
            rayleigh: 4,
            mieCoefficient: 0.025,
            mieDirectionalG: 0.8,
            elevation: 1,
            azimuth: 180,
          },
          light: {
            ambient: 0x443333,
            ground: 0x000000,
            dirColor: 0xff4500,
            dirIntensity: 5.0,
            dirPos: [-100, 50, 100],
          },
          fog: { color: 0x553355, density: 0.0025 },
          env: {
            exposure: 0.4,
            bloomStrength: 0.3,
            bloomThreshold: 0.95,
            sunColor: 0xff4500,
          },
        },
        Night: {
          sky: {
            turbidity: 10,
            rayleigh: 0,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.7,
            elevation: -5,
            azimuth: 180,
          },
          light: {
            ambient: 0x050515,
            ground: 0x000000,
            dirColor: 0x111133,
            dirIntensity: 1.0,
            dirPos: [0, 100, 0],
          }, // Moonlight
          fog: { color: 0x050510, density: 0.003 },
          env: {
            exposure: 0.3,
            bloomStrength: 1.5,
            bloomThreshold: 0.6,
            sunColor: 0x000000,
          }, // High bloom for lights
        },
      };

      // --- MOBILE SUPPORT ---
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      let touchStartX, touchStartY;

      function setupMobileControls() {
        if (!isMobile) return;

        const mobileUI = document.getElementById("mobile-controls");
        // Don't show immediately - will be shown when game starts

        const joystickContainer = document.getElementById("joystick-container");
        const joystickInner = document.getElementById("joystick-inner");
        const sprintBtn = document.getElementById("sprint-btn");

        let joystickActive = false;
        let dragOrigin = { x: 0, y: 0 };
        const maxDrag = 50;

        joystickContainer.addEventListener("touchstart", (e) => {
          joystickActive = true;
          const touch = e.touches[0];
          const rect = joystickContainer.getBoundingClientRect();
          dragOrigin = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
          e.preventDefault();
        }, { passive: false });

        window.addEventListener("touchmove", (e) => {
          if (!joystickActive) return;
          const touch = e.touches[0];
          
          let dx = touch.clientX - dragOrigin.x;
          let dy = touch.clientY - dragOrigin.y;
          
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > maxDrag) {
            dx = (dx / distance) * maxDrag;
            dy = (dy / distance) * maxDrag;
          }
          
          joystickInner.style.transform = `translate(${dx}px, ${dy}px)`;
          
          // Simple directional mapping based on joystick position
          moveForward = dy < -20;
          moveBackward = dy > 20;
          moveLeft = dx < -20;
          moveRight = dx > 20;
        }, { passive: false });

        window.addEventListener("touchend", () => {
          joystickActive = false;
          joystickInner.style.transform = "translate(0, 0)";
          moveForward = false;
          moveBackward = false;
          moveLeft = false;
          moveRight = false;
        });

        // Sprint Button
        sprintBtn.addEventListener("touchstart", (e) => {
          isSprinting = !isSprinting; // Toggle on mobile
          sprintBtn.classList.toggle("active", isSprinting);
          e.preventDefault();
        }, { passive: false });

        // Touch to Look
        window.addEventListener("touchstart", (e) => {
          if (e.target.closest("#mobile-controls") || !gameStarted) return;
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        }, { passive: false });

        window.addEventListener("touchmove", (e) => {
          if (e.target.closest("#mobile-controls") || !gameStarted) return;
          if (touchStartX === undefined) return;

          const touchX = e.touches[0].clientX;
          const touchY = e.touches[0].clientY;
          
          const dx = touchX - touchStartX;
          const dy = touchY - touchStartY;

          const sensitivity = 0.005;
          
          // Rotate camera directly
          camera.rotation.y -= dx * sensitivity;
          // Pitch rotation needs careful clamping
          camera.rotation.order = 'YXZ'; // Important for FPS rotation
          camera.rotation.x -= dy * sensitivity;
          camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));

          touchStartX = touchX;
          touchStartY = touchY;
        }, { passive: false });
      }

      let currentSkyConfig = TimePresets.Morning;
      let bloomPass;
      let sunMesh;
      const petals = [];
      const people = [];
      let busGroup;
      let waterMesh;
      let moonMesh; // Moved to global/top scope to avoid TDZ errors

      // --- 3D TITLE ---
      let titleGroup;

      function create3DTitle() {
        titleGroup = new THREE.Group();
        const loader = new THREE.FontLoader();
        loader.load(
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json",
          function (font) {
            const material = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              emissive: 0xffffff,
              emissiveIntensity: 0.1,
              roughness: 0.1,
              metalness: 0.4,
            });

            function createTextLine(message, yPos, scale = 1) {
              const textGeo = new THREE.TextGeometry(message, {
                font: font,
                size: 4.5 * scale,
                height: 1.5,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.2,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 5,
              });

              textGeo.center();
              const mesh = new THREE.Mesh(textGeo, material);
              mesh.rotation.x = -0.1; // Slight tilt
              mesh.castShadow = true;
              mesh.receiveShadow = true;

              // Static Position: No animation
              mesh.userData = { targetY: yPos };
              mesh.position.y = yPos; 
              // Also add a slight Z offset for drama?
              // mesh.position.z += 20; 

              titleGroup.add(mesh);
            }

            // Create 3 Rows
            // Create 3 Rows (Vertical spacing reduced - "close")
            createTextLine("RUN", 4.5);
            createTextLine("LONDON", 0);
            createTextLine("RUN", -4.5);

            // Position: In front of start camera (z=80)
            titleGroup.position.set(0, 10, 30);
            // Face Camera (Camera looks down -Z, so Text facing +Z is correct)

            scene.add(titleGroup);
          }
        );
      }

      // --- Initialization ---
      function init() {
        const container = document.getElementById("canvas-container");

        // 1. Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2d1b4e); // Deep Purple
        // Vibrant Sunset Fog
        scene.fog = new THREE.FogExp2(0x553355, 0.002);

        // 2. Camera
        // 2. Camera: CINEMATIC LENS (50mm equiv approx)
        camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.y = 1.6;
        camera.position.z = 80;

        // 3. Renderer - OPTIMIZED SETTINGS
        renderer = new THREE.WebGLRenderer({
          antialias: false, // Disabled for performance (Composer handles it)
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.4; // Darker exposure for sunset drama
        container.appendChild(renderer.domElement);

        // 4. Lighting - RED SUNSET
        // Darker ambient to emphasize the sun
        const ambientLight = new THREE.HemisphereLight(0x443333, 0x000000, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xff4500, 5.0); // ORANGE/RED SUN
        dirLight.position.set(-100, 50, 100); // Lower angle
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // REDUCED FROM 4096
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.bias = -0.0005; // Adjusted bias
        dirLight.shadow.radius = 1;

        const d = 400;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // Sun Visual
        const sunGeo = new THREE.SphereGeometry(40, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
        sunMesh = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sunMesh);

        // Moon Visual (Hidden by default)
        const moonGeo = new THREE.SphereGeometry(30, 32, 32);
        const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
        moonMesh = new THREE.Mesh(moonGeo, moonMat);
        scene.add(moonMesh);
        moonMesh.visible = false;

        // 5. Controls
        controls = new THREE.PointerLockControls(camera, document.body);

        // --- POST PROCESSING SETUP ---
        composer = new THREE.EffectComposer(renderer);

        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom - DYNAMIC
        bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        composer.addPass(bloomPass);

        // Cinematic Grain
        const filmPass = new THREE.FilmPass(
          0.2, // reduced noise
          0.0, // disabled scanlines (expensive)
          0, 
          false
        );
        composer.addPass(filmPass);

        const uiLayer = document.getElementById("ui-layer");
        const startBtn = document.getElementById("start-btn");

        // Initial Time Set (Moved to end)

        startBtn.addEventListener("click", () => {
          // Defer heavy operations to next frame for better responsiveness
          requestAnimationFrame(() => {
            // Add game-active class for rotation prompt
            document.body.classList.add("game-active");
            
            if (isMobile) {
              uiLayer.classList.add("hidden");
              // Show mobile controls when game starts
              const mobileUI = document.getElementById("mobile-controls");
              if (mobileUI) mobileUI.style.display = "block";
              if (!gameStarted) {
                gameStarted = true;
                const randomDelay = Math.random() * (8000 - 3000) + 3000;
                setTimeout(triggerSnatch, randomDelay);
              }
            } else {
              controls.lock();
            }
            if (titleGroup) titleGroup.visible = false; // Hide title on start
          });
        });

        controls.addEventListener("lock", () => {
          uiLayer.classList.add("hidden");
          if (!gameStarted) {
            gameStarted = true;
            // RANDOM TIME: Between 3s and 8s
            const randomDelay = Math.random() * (8000 - 3000) + 3000;
            console.log(
              "Snatch event scheduled in: " +
                Math.round(randomDelay / 1000) +
                "s"
            );
            setTimeout(triggerSnatch, randomDelay);
          }
        });

        controls.addEventListener("unlock", () => {
          if (!gameEnded) uiLayer.classList.remove("hidden");
        });

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        // --- AUDIO SETUP ---
        const listener = new THREE.AudioListener();
        camera.add(listener);

        const sound = new THREE.Audio(listener);
        walkSound = new THREE.Audio(listener); // Global walkSound
        runSound = new THREE.Audio(listener);  // Global runSound
        const audioLoader = new THREE.AudioLoader();
        
        // Load background ambience
        audioLoader.load(
            'city-street-downtown-52115.mp3', 
            function(buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(true);
                sound.setVolume(0.6);
                sound.play(); // Play immediately if possible
            },
            undefined,
            function(error) {
                console.warn('Background audio failed to load:', error);
            }
        );

        // Load Footsteps
        audioLoader.load(
            'footsteps-on-pebbles-stones-on-the-road-rough-stones-109236.mp3', 
            buffer => {
                walkSound.setBuffer(buffer);
                walkSound.setLoop(true);
                walkSound.setVolume(0.4);
            },
            undefined,
            error => console.warn('Walk sound failed to load:', error)
        );

        audioLoader.load(
            'running-on-dirt-road-345729.mp3', 
            buffer => {
                runSound.setBuffer(buffer);
                runSound.setLoop(true);
                runSound.setVolume(0.5);
            },
            undefined,
            error => console.warn('Run sound failed to load:', error)
        );

        // Play audio on Start Button Click
        const audioStartBtn = document.getElementById("start-btn");
        if(audioStartBtn) {
            audioStartBtn.addEventListener("click", () => {
                // Resume context if suspended
                if (listener.context.state === 'suspended') {
                    listener.context.resume().then(() => {
                        console.log("AudioContext resumed by start button");
                    });
                }
                
                // Ensure background sound plays
                if(sound.buffer) {
                     sound.stop(); // Stop first to reset
                     sound.play(); 
                     console.log("Background audio started");
                } else {
                     console.warn("Background audio buffer not loaded yet");
                }
            });
        }
        
        // GLOBAL AUDIO RESUME FAILSAFE
        function resumeAudio() {
            if (listener.context.state === 'suspended') {
                listener.context.resume().then(() => {
                    console.log("AudioContext resumed by global interaction");
                });
            }
        }
        document.addEventListener('click', resumeAudio);
        document.addEventListener('touchstart', resumeAudio);
        document.addEventListener('keydown', resumeAudio);

        // 6. Build World
        createSky(); // MOVED UP: Must be first for Sun reference
        createRiver();
        createBoats(); // NEW: River Boats
        createBridge();
        createCity();
        createNeonCity();
        createDaffodils();
        create3DTitle(); // NEW: 3D Title
        createFallingPetals();
        createCrowd();
        createBus();
        createSnatcher();
        createLensFlares(); // NEW: Add Lens Flares

        setupMobileControls(); // Enable touch support

        // Initial Time Set (Must be after createSky and lights)
        setTimeOfDay("Evening");

        window.addEventListener("resize", onWindowResize);

        console.log("Init sequence complete. Starting animation loop.");
        animate();

        // SEQUENTIAL LOADING LOGIC
        const loadingText = document.getElementById('loading-text');
        const loader = document.getElementById('loading-screen');
        const btn = document.getElementById('start-btn');
        const disclaimer = document.getElementById('intro-disclaimer');
        const subtext = document.getElementById('loading-subtext');

        // Sequence Data
        const sequence = [
            "This is an interactive protest.",
            "You will walk through the city.",
            "Use Arrow Keys to move.",
            "Mouse to look around.",
            "You may try to react.",
            "Pay attention."
        ];

        // Step 1: Show Disclaimer & Start Loading Simultaneously
        setTimeout(() => {
            disclaimer.style.opacity = '1';
            
            // Start loading progress logic MOVED to after disclaimer
            let progress = 0;
            
            // Step 2: After 4s, hide disclaimer and show loader with instructions
            setTimeout(() => {
                disclaimer.style.opacity = '0';
                
                setTimeout(() => {
                    disclaimer.style.display = 'none';
                    disclaimer.style.display = 'none';
                    loadingText.style.opacity = '1';
                    
                    // START PROGRESS BAR HERE (so it starts at 0%)
                    const interval = setInterval(() => {
                        progress += 4;
                        if (progress > 100) progress = 100;
                        loadingText.childNodes[0].nodeValue = Math.floor(progress) + "%";
                        if (progress === 100) clearInterval(interval);
                    }, 150);
                    
                    // Show first TWO instructions combined
                    subtext.innerText = sequence[0] + " " + sequence[1];
                    subtext.style.opacity = 1;
                    
                    // Cycle through remaining instructions in pairs
                    let instructionIndex = 2;
                    const instructionInterval = setInterval(() => {
                        if (instructionIndex < sequence.length) {
                            subtext.style.opacity = 0;
                            setTimeout(() => {
                                // Combine two instructions if both exist
                                const text1 = sequence[instructionIndex];
                                const text2 = sequence[instructionIndex + 1];
                                
                                if (text1 && text2) {
                                    subtext.innerText = text1 + " " + text2;
                                } else if (text1) {
                                    subtext.innerText = text1;
                                } else {
                                    subtext.innerText = "";
                                }
                                
                                subtext.style.opacity = 1;
                            }, 150);
                            instructionIndex += 2; // Move by 2
                        } else {
                            clearInterval(instructionInterval);
                            // Ensure final opacity is 1 just in case
                            subtext.style.opacity = 1;
                        }
                    }, 2500); // Show each pair for 2.5 seconds (slightly longer reading time)
                    
                    // Wait for loading to complete AND instructions to finish
                    const checkComplete = setInterval(() => {
                        // instructionIndex starts at 2. 
                        // It increments by 2 each cycle (4, 6). 
                        // sequence length is 6.
                        // When it hits 6, it stops.
                        // So we wait for instructionIndex >= 6
                        if (progress >= 100 && instructionIndex >= sequence.length) {
                             clearInterval(checkComplete);
                             clearInterval(instructionInterval);
                            setTimeout(() => {
                                loader.style.opacity = '0';
                                setTimeout(() => {
                                    loader.style.display = 'none';
                                    loader.classList.add('hidden');
                                    loader.style.pointerEvents = 'none';
                                    btn.style.display = 'block';
                                    btn.style.pointerEvents = 'auto';
                                    void btn.offsetWidth;
                                    btn.style.opacity = '1';
                                }, 200);
                            }, 300);
                        }
                    }, 50);
                }, 400);
            }, 4000); // 4 seconds for disclaimer
        }, 300);
      }

      function onKeyDown(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "Space":
            isSprinting = true;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
          case "Space":
            isSprinting = false;
            break;
        }
      }

      // --- Snatch Logic ---
      function triggerSnatch() {
        if (phoneSnatched) return;

        // Spawn behind player
        snatcherMesh.position.set(
          camera.position.x - 2,
          0,
          camera.position.z + 20
        );

        // 1. APPROACH PHASE
        snatcherSpeed = 22;

        // Wait for him to reach camera
        setTimeout(() => {
          phoneSnatched = true;
          // Surge ahead instantly
          snatcherMesh.position.z = camera.position.z - 10;
          snatchActive = true; // Enable distance check only NOW
          
          // Catch delay
          canBeCaught = false;
          setTimeout(() => {
            canBeCaught = true;
          }, 2000);

          // UI Changes
          const phoneOverlay = document.getElementById("phone-overlay");
          phoneOverlay.style.display = "flex"; // Show phone
          phoneOverlay.style.bottom = "-40px"; // Slide into view
          phoneOverlay.style.opacity = "1";
          phoneOverlay.style.transform = "translate(0, 0)"; // Reset transform
          
          // Then animate it away INSTANTLY
          setTimeout(() => {
            phoneOverlay.style.transform = "translate(500px, -200px)";
            phoneOverlay.style.opacity = "0";
            // Hide completely after animation
            setTimeout(() => {
              phoneOverlay.style.visibility = "hidden"; // Force visibility hidden
              phoneOverlay.style.display = "none";
            }, 300);
          }, 0); // NO DELAY - Snatch immediately

          const alert = document.getElementById("alert-msg");
          alert.style.display = "block";

          // Show HUD
          document.getElementById("game-hud").style.display = "block";

          // Camera Jolt
          camera.rotation.z += 0.05;
          setTimeout(() => (camera.rotation.z -= 0.05), 150);

          // Add loot to snatcher hand
          const lootGeo = new THREE.BoxGeometry(0.1, 0.2, 0.05);
          const lootMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const loot = new THREE.Mesh(lootGeo, lootMat);
          loot.position.set(0.5, 1.2, -0.5);
          snatcherMesh.add(loot);

          // 2. GETAWAY START
          snatcherSpeed = 12;
          
          // 3. SPEED BOOST AFTER 5 SECONDS
          setTimeout(() => {
            if (!gameEnded && snatchActive) {
              snatcherSpeed = 28; // Significant speed increase
            }
          }, 5000); // 5 seconds after robbery
        }, 900);
      }

      function endGame(won) {
        gameEnded = true;
        controls.unlock();
        const endScreen = document.getElementById("end-screen");
        const endTitle = document.getElementById("end-title");
        const endMsg = document.getElementById("end-msg");

        endScreen.style.display = "flex";
        document.getElementById("ui-layer").style.display = "none";

        // CLEANUP
        document.getElementById("alert-msg").style.display = "none";
        document.getElementById("game-hud").style.display = "none";
        document.getElementById("thief-marker").style.display = "none";

        if (won) {
          endTitle.innerText = "SUCCESS";
          endTitle.style.color = "#00ff88";
          endMsg.innerHTML =
            "You caught the thief!<br><b>Phone retrieved safely.</b>";
        } else {
           // Skip "FAILED" screen entirely as requested
           // Immediately start the narrative/stats sequence
           document.getElementById('end-screen').style.display = 'none'; // Ensure card is hidden
            
           // NARRATIVE SEQUENCE
           // Hide restart button initially
           document.getElementById('restart-area').style.display = 'none';
           
           showNarrativeSequence();
        }
      }

      function showNarrativeSequence() {
          const overlay = document.getElementById('narrative-overlay');
          const caseStatus = document.getElementById('case-status-ui');
          const slide1 = document.getElementById('nar-slide-1');
          const slide2 = document.getElementById('nar-slide-2');
          const chartSlide = document.getElementById('chart-slide');
          const storySlide = document.getElementById('story-slide');
          const endCard = document.getElementById('end-card-container');
          
          // 1. Show Case Status
          overlay.style.visibility = 'visible';
          overlay.style.opacity = '1';
          caseStatus.classList.add('show');
          
          // 2. Hide original end card
          if (endCard) endCard.style.opacity = '0';
          
          // 3. SHOW TEXT STATS (Slide 1 & 2)
          setTimeout(() => {
              caseStatus.style.opacity = '0';
              setTimeout(() => {
                  slide1.style.opacity = '1';
              }, 1000);
          }, 4000);
          
          setTimeout(() => {
              slide1.style.opacity = '0';
              setTimeout(() => {
                  slide2.style.opacity = '1';
              }, 1000);
          }, 8000);

          // 4. SHOW QUESTION SLIDE INSTEAD OF STORY SLIDE
    setTimeout(() => {
        slide2.style.opacity = '0';
        setTimeout(() => {
            slide2.style.display = 'none';
            // Show new Question Slide
            const qSlide = document.getElementById('question-slide');
            qSlide.style.display = 'flex';
            setTimeout(() => {
                qSlide.style.opacity = '1';
            }, 100);
        }, 2000);
    }, 23000); // Trigger after slide 2 reading time (8000ms + 15000ms)
      }

      function handleQuestionAnswer(answer) {
          const qSlide = document.getElementById('question-slide');
          qSlide.style.opacity = '0'; // Fade out question
          
          setTimeout(() => {
              qSlide.style.display = 'none';
              
              if (answer === 'yes' || answer === 'someone') {
                  // Show Story Form
                  const storySlide = document.getElementById('story-slide');
                  storySlide.style.display = 'flex';
                  setTimeout(() => {
                      storySlide.style.opacity = '1';
                  }, 100);
              } else {
                  // NO -> Show Credits
                  showCredits();
              }
          }, 1000); // Fade out time
      }
      
      function showCredits() {
          // Hide Question or Story slides if open
          const qSlide = document.getElementById('question-slide');
          const storySlide = document.getElementById('story-slide');
          const confirmSlide = document.getElementById('confirmation-slide');
          
          if(qSlide) qSlide.style.display = 'none';
          if(storySlide) storySlide.style.display = 'none';
          if(confirmSlide) confirmSlide.style.display = 'none';
          
          const credits = document.getElementById('credits-slide');
          credits.style.display = 'flex';
          
          // Ensure overlay is visible if it was hidden
          document.getElementById('narrative-overlay').style.display = 'flex'; 
          document.getElementById('narrative-overlay').style.visibility = 'visible';
          document.getElementById('narrative-overlay').style.opacity = '1';

          setTimeout(() => {
              credits.style.opacity = '1';
          }, 100);
      }


      // --- SUPABASE INTEGRATION ---
      // Production credentials (safe to use - publishable key with RLS enabled)
      const SBS_URL = 'https://hxzipcgggwdyognszuzu.supabase.co';
      const SBS_KEY = 'sb_publishable_8rBnzjoiJGqfs1UYntY4lg_O7SOaIvk';
      // Initialize client (will be available if CDN loads correctly)
      let supabaseClient;

      function initSupabase() {
          if (window.supabase) {
              supabaseClient = window.supabase.createClient(SBS_URL, SBS_KEY);
              console.log("Supabase Initialized");
          } else {
              console.error("Supabase lib not loaded");
          }
      }
      // Call init immediately (or inside main init, but safe here if script loaded)
      // We'll call it inside the main init() to be safe, or just timeout.
      setTimeout(initSupabase, 1000); 

      async function submitStory() {
          const btn = document.querySelector('.share-btn');
          const textarea = document.querySelector('.story-form textarea');
          const text = textarea.value.trim();

          if (!text) return;

          btn.innerText = 'SAVING...';
          btn.disabled = true;

          if (!supabaseClient) {
             btn.innerText = 'ERROR (LIB)';
             return;
          }

          try {
              const { data, error } = await supabaseClient
                  .from('stories')
                  .insert([{ content: text }]);

              if (error) {
                  console.error('Supabase Error:', error);
                  btn.innerText = 'ERROR SAVING';
                  btn.disabled = false;
              } else {
                  console.log('Story Saved:', data);
                  
                  // Add a new NPC to the city for this story
                  addStoryNPC();
                  
                  // Show confirmation slide
                  document.getElementById('story-slide').style.opacity = '0';
                  setTimeout(() => {
                      document.getElementById('story-slide').style.display = 'none';
                      const confirmSlide = document.getElementById('confirmation-slide');
                      confirmSlide.style.display = 'flex';
                      setTimeout(() => {
                          confirmSlide.style.opacity = '1';
                      }, 100);
                  }, 1000);
              }
          } catch (err) {
               console.error('Submission Exception:', err);
               btn.innerText = 'ERROR';
               btn.disabled = false;
          }
      }

      // Add a new NPC to the city when a story is submitted
      function addStoryNPC() {
          const shirtColor = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
          const npc = createRealisticHuman(shirtColor);
          
          // Random position anywhere in the city
          const side = Math.random() > 0.5 ? 1 : -1;
          const xPos = (8.5 + (Math.random() - 0.5) * 4) * side; // Sidewalk area
          const zPos = (Math.random() - 0.5) * 4000; // Anywhere along city (-2000 to 2000)
          
          npc.position.set(xPos, 0, zPos);
          npc.rotation.y = Math.random() * Math.PI * 2;
          
          const speed = 0.05 + Math.random() * 0.05;
          const direction = Math.random() > 0.5 ? 1 : -1;
          
          people.push({
            group: npc,
            speed: speed,
            dir: direction,
            side: side
          });
          
          scene.add(npc);
          console.log('New NPC added for submitted story at z:', zPos);
      }

      function skipStory() {
          // Show credits slide
          document.getElementById('story-slide').style.opacity = '0';
          setTimeout(() => {
              document.getElementById('story-slide').style.display = 'none';
              const creditsSlide = document.getElementById('credits-slide');
              creditsSlide.style.display = 'flex';
              setTimeout(() => {
                  creditsSlide.style.opacity = '1';
              }, 100);
          }, 1000);
      }

      function initTheftChart() {
          const canvas = document.getElementById('theft-chart');
          const ctx = canvas.getContext('2d');
          
          // Create Gradient
          const gradient = ctx.createLinearGradient(0, 0, 0, 400);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');   // Top: Semi-transparent white
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');   // Bottom: Transparent

          new Chart(ctx, {
              type: 'line',
              data: {
                  labels: ['2019', '2020', '2021', '2022', '2023', '2024'],
                  datasets: [{
                      label: 'Recorded Thefts',
                      data: [91481, 55820, 63777, 90810, 115261, 117211],
                      borderColor: '#fff',
                      backgroundColor: gradient, // USE GRADIENT
                      borderWidth: 3,
                      pointBackgroundColor: '#000',
                      pointBorderColor: '#fff',
                      pointBorderWidth: 2,
                      pointRadius: 0,        // Clean look: no dots by default
                      pointHoverRadius: 6,   // Dots on hover
                      tension: 0.4,          // Smoother curve
                      fill: true,
                      hitRadius: 20
                  }]
              },
              options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  interaction: {
                    mode: 'index',
                    intersect: false,
                  },
                  plugins: {
                      legend: { display: false },
                      tooltip: {
                          backgroundColor: 'rgba(0,0,0,0.8)',
                          titleColor: '#fff',
                           titleFont: { family: 'Inter', size: 14 },
                           bodyColor: '#fff',
                           bodyFont: { family: 'Inter', size: 12, weight: 'bold' },
                           borderColor: 'rgba(255,255,255,0.2)',
                           borderWidth: 1,
                          padding: 12,
                          cornerRadius: 4,
                          displayColors: false,
                          callbacks: {
                              label: function(context) {
                                  return context.parsed.y.toLocaleString() + ' CASES';
                              }
                          }
                      }
                  },
                  scales: {
                      y: {
                          beginAtZero: true,
                          grid: { color: 'rgba(255,255,255,0.05)', drawBorder: false },
                           ticks: { color: '#666', font: { family: 'Inter', size: 10 } }
                       },
                       x: {
                           grid: { display: false },
                           ticks: { color: '#888', font: { family: 'Inter', size: 11, weight: '500' } }
                       }
                  }
              }
          });
      }

      // --- World Building Functions ---

      // HELPER: Procedural Noise for Gritty Realism
      function createNoiseTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#808080";
        ctx.fillRect(0, 0, 512, 512);
        for (let i = 0; i < 80000; i++) {
          ctx.fillStyle = Math.random() < 0.5 ? "#707070" : "#909090";
          ctx.globalAlpha = 0.3;
          ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }

      function createWaterNormals() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#8080ff";
        ctx.fillRect(0, 0, 512, 512);
        for (let i = 0; i < 20000; i++) {
          ctx.fillStyle = Math.random() < 0.5 ? "#7070ff" : "#9090ff";
          ctx.fillRect(Math.random() * 512, Math.random() * 512, 4, 4);
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
      }

      // HELPER: Procedural Brick Texture
      function createBrickTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        
        ctx.fillStyle = "#a52a2a"; // Lighter red brick
        ctx.fillRect(0, 0, 512, 512);

        ctx.strokeStyle = "#000000"; // Black Mortar for extreme contrast
        ctx.lineWidth = 3;
        
        const brickW = 32;
        const brickH = 16;
        
        for (let y = 0; y < 512; y += brickH) {
          let offset = (y / brickH) % 2 === 0 ? 0 : brickW / 2;
          for (let x = -brickW; x < 512; x += brickW) {
            ctx.strokeRect(x + offset, y, brickW, brickH);
            // Highlight
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            ctx.fillRect(x + offset + 2, y + 2, brickW - 4, 3);
          }
        }
        
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }

      // HELPER: Cherry Blossom Tree (Spring)
      function createCherryBlossomTree(x, z) {
        const group = new THREE.Group();
        group.position.set(x, 0, z);

        // Trunk
        const trunkGeo = new THREE.CylinderGeometry(0.2, 0.4, 3, 7);
        const trunkMat = new THREE.MeshStandardMaterial({
          color: 0x3d2817,
          roughness: 1.0,
        });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1.5;
        trunk.castShadow = true;
        group.add(trunk);

        // Foliage - Pink Particles
        const leavesGeo = new THREE.BufferGeometry();
        const leafCount = 800;
        const positions = [];
        const colors = [];
        const color1 = new THREE.Color(0xffb7c5); // Light Pink
        const color2 = new THREE.Color(0xff69b4); // Deep Pink

        for (let i = 0; i < leafCount; i++) {
          // Cloud shape around top
          const r = Math.random() * 2.5;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;

          const lx = r * Math.sin(phi) * Math.cos(theta);
          const ly = r * Math.sin(phi) * Math.sin(theta) + 3.5; // Raised center
          const lz = r * Math.cos(phi);

          positions.push(lx, ly, lz);

          const mix = Math.random();
          const col = color1.clone().lerp(color2, mix);
          colors.push(col.r, col.g, col.b);
        }

        leavesGeo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        leavesGeo.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );

        const leavesMat = new THREE.PointsMaterial({
          size: 0.3,
          vertexColors: true,
        });
        const leaves = new THREE.Points(leavesGeo, leavesMat);
        group.add(leaves);

        scene.add(group);
      }

      // Replacing default bus
      function createBus() {
        // New Routemaster Style
        busGroup = new THREE.Group();
        busGroup.position.set(0, 0.2, -600);

        // Vibrant Red Paint
        const redPaint = new THREE.MeshStandardMaterial({
          color: 0xe60000,
          roughness: 0.2,
          metalness: 0.6,
        });
        const blackGlass = new THREE.MeshStandardMaterial({
          color: 0x000000,
          roughness: 0.0,
          metalness: 1.0,
        });
        const greyMetal = new THREE.MeshStandardMaterial({ color: 0x555555 });

        // Main Body (Curved corners simulation via scaling)
        const bodyGeo = new THREE.BoxGeometry(3.5, 4.2, 12);
        const body = new THREE.Mesh(bodyGeo, redPaint);
        body.position.y = 2.8;
        body.castShadow = true;
        busGroup.add(body);

        // Windows Strip (Lower)
        const lowerWin = new THREE.Mesh(
          new THREE.BoxGeometry(3.6, 1.2, 10),
          blackGlass
        );
        lowerWin.position.y = 2.2;
        busGroup.add(lowerWin);

        // Windows Strip (Upper)
        const upperWin = new THREE.Mesh(
          new THREE.BoxGeometry(3.6, 1.2, 10),
          blackGlass
        );
        upperWin.position.y = 4.2;
        busGroup.add(upperWin);

        // Front Curved Window
        const frontGeo = new THREE.CylinderGeometry(
          1.6,
          1.6,
          3,
          16,
          1,
          false,
          0,
          Math.PI
        );
        const frontGlass = new THREE.Mesh(frontGeo, blackGlass);
        frontGlass.rotation.z = Math.PI / 2;
        frontGlass.position.set(0, 3.5, 6);
        busGroup.add(frontGlass);

        // Rear Curved Window
        const rearGlass = new THREE.Mesh(frontGeo, blackGlass);
        rearGlass.rotation.z = Math.PI / 2;
        rearGlass.rotation.y = Math.PI;
        rearGlass.position.set(0, 3.5, -6);
        busGroup.add(rearGlass);

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
        wheelGeo.rotateZ(Math.PI / 2);
        const w1 = new THREE.Mesh(wheelGeo, greyMetal);
        w1.position.set(1.5, 0.8, 3.5);
        busGroup.add(w1);
        const w2 = new THREE.Mesh(wheelGeo, greyMetal);
        w2.position.set(-1.5, 0.8, 3.5);
        busGroup.add(w2);
        const w3 = new THREE.Mesh(wheelGeo, greyMetal);
        w3.position.set(1.5, 0.8, -3.5);
        busGroup.add(w3);
        const w4 = new THREE.Mesh(wheelGeo, greyMetal);
        w4.position.set(-1.5, 0.8, -3.5);
        busGroup.add(w4);

        scene.add(busGroup);
      }

      function createSky() {
        sky = new THREE.Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sun = new THREE.Vector3();
      }

      function setTimeOfDay(timeName) {
        console.log("Setting time to:", timeName);
        const config = TimePresets[timeName];
        if (!config) return;

        // 1. Sky Uniforms
        const uniforms = sky.material.uniforms;
        uniforms["turbidity"].value = config.sky.turbidity;
        uniforms["rayleigh"].value = config.sky.rayleigh;
        uniforms["mieCoefficient"].value = config.sky.mieCoefficient;
        uniforms["mieDirectionalG"].value = config.sky.mieDirectionalG;

        const phi = THREE.MathUtils.degToRad(90 - config.sky.elevation);
        const theta = THREE.MathUtils.degToRad(config.sky.azimuth);
        sun.setFromSphericalCoords(1, phi, theta);
        uniforms["sunPosition"].value.copy(sun);

        // 2. Lighting
        const ambient = scene.getObjectByProperty("type", "HemisphereLight");
        if (ambient) {
          ambient.color.setHex(config.light.ambient);
          ambient.groundColor.setHex(config.light.ground);
        }

        const dirLight = scene.getObjectByProperty("type", "DirectionalLight");
        if (dirLight) {
          dirLight.color.setHex(config.light.dirColor);
          dirLight.intensity = config.light.dirIntensity;
          dirLight.position.set(...config.light.dirPos);

          // Move sun mesh
          if (sunMesh) {
            sunMesh.position.copy(dirLight.position).multiplyScalar(2.0);
            sunMesh.material.color.setHex(config.env.sunColor);
            sunMesh.visible = config.sky.elevation > 0;
          }

          // Move Moon Mesh
          if (moonMesh) {
            if (config.sky.elevation <= 0) {
              // Night
              moonMesh.visible = true;
              // Opposite to sun/light direction? Or just up?
              // config.light.dirPos is the main light source (Moonlight at night)
              moonMesh.position
                .set(...config.light.dirPos)
                .normalize()
                .multiplyScalar(400);
              moonMesh.lookAt(0, 0, 0);
            } else {
              moonMesh.visible = false;
            }
          }
        }

        // 3. Fog & Env
        scene.fog.color.setHex(config.fog.color);
        scene.fog.density = config.fog.density;
        scene.background.setHex(config.fog.color); // Match background to fog

        if (renderer) renderer.toneMappingExposure = config.env.exposure;
        if (bloomPass) {
          bloomPass.strength = config.env.bloomStrength;
          bloomPass.threshold = config.env.bloomThreshold;
        }

        // 4. Update Reflection Probe
        if (renderer) {
          const pmremGenerator = new THREE.PMREMGenerator(renderer);
          const sceneEnv = new THREE.Scene();
          sceneEnv.add(sky);
          const renderTarget = pmremGenerator.fromScene(sceneEnv);
          scene.environment = renderTarget.texture;
        }
      }

      function createLensFlares() {
        const textureLoader = new THREE.TextureLoader();
        const textureFlare0 = textureLoader.load(
          "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png"
        );
        const textureFlare3 = textureLoader.load(
          "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare3.png"
        );

        const lensflare = new THREE.Lensflare();
        lensflare.addElement(new THREE.LensflareElement(textureFlare0, 700, 0));
        lensflare.addElement(
          new THREE.LensflareElement(textureFlare3, 60, 0.6)
        );
        lensflare.addElement(
          new THREE.LensflareElement(textureFlare3, 70, 0.7)
        );
        lensflare.addElement(
          new THREE.LensflareElement(textureFlare3, 120, 0.9)
        );
        lensflare.addElement(new THREE.LensflareElement(textureFlare3, 70, 1));

        // Attach to the sun position visual
        const dirLight = scene.getObjectByProperty("type", "DirectionalLight");
        if (dirLight) {
          dirLight.add(lensflare);
        }
      }

      function createRiver() {
        const waterGeometry = new THREE.PlaneGeometry(2000, 450);

        const normalMap = createWaterNormals();
        normalMap.repeat.set(5, 5);

        waterMesh = new THREE.Water(waterGeometry, {
          textureWidth: 512,
          textureHeight: 512,
          waterNormals: normalMap,
          sunDirection: new THREE.Vector3(),
          sunColor: 0xffaa33,
          waterColor: 0x0044ff, // More vibrant blue water
          distortionScale: 3.7,
          fog: scene.fog !== undefined,
        });

        waterMesh.rotation.x = -Math.PI / 2;
        waterMesh.position.y = -16; // Lowered to avoid bridge clipping
        scene.add(waterMesh);

        // Update sun direction for water
        if (sun)
          waterMesh.material.uniforms["sunDirection"].value
            .copy(sun)
            .normalize();
      }

      function createBridge() {
        const noiseTex = createNoiseTexture();
        noiseTex.repeat.set(4, 50);

        const bridgeLength = 300;
        const roadGeo = new THREE.BoxGeometry(20, 1, bridgeLength);
        const roadMat = new THREE.MeshStandardMaterial({
          color: 0x333333, // Slightly brighter for visibility
          roughness: 0.8,
          roughnessMap: noiseTex, // Gritty asphalt
          metalness: 0.1,
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.position.y = -0.5;
        road.receiveShadow = true;
        scene.add(road);

        const sideWalkGeo = new THREE.BoxGeometry(5, 1.4, bridgeLength);
        const sideWalkMat = new THREE.MeshStandardMaterial({
          color: 0xaaaaaa,
          roughness: 0.9,
          map: noiseTex, // Concrete texture
        });

        const leftWalk = new THREE.Mesh(sideWalkGeo, sideWalkMat);
        leftWalk.position.set(-8.5, -0.3, 0);
        leftWalk.receiveShadow = true;
        scene.add(leftWalk);

        const rightWalk = new THREE.Mesh(sideWalkGeo, sideWalkMat);
        rightWalk.position.set(8.5, -0.3, 0);
        rightWalk.receiveShadow = true;
        scene.add(rightWalk);

        createRailing(-10.5, bridgeLength);
        createRailing(10.5, bridgeLength);
        createTower(0, 0, -60);
        createTower(0, 0, 60);
        createCables();

        for (let z = -140; z <= 140; z += 20) {
          if (z > -50 && z < 50) continue;
          createLampPost(-10.5, z);
          createLampPost(10.5, z);
        }
        for (let z = -135; z <= 135; z += 15) {
          if (z > -45 && z < 45) continue;
          createCherryBlossomTree(-9, z);
          createCherryBlossomTree(9, z);
        }
      }

        function createSnatcher() {
            snatcherMesh = new THREE.Group();
            
            // --- BIKE MATERIALS ---
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9, roughness: 0.2 }); 
            const tireMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.1 });

            // --- WHEELS (Thickened) ---
            const createWheel = () => {
                const wheelGroup = new THREE.Group();
                // Tire: Thicker tube (0.08 -> 0.12)
                const tire = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.12, 12, 32), tireMat);
                tire.rotation.y = Math.PI/2;
                wheelGroup.add(tire);
                // Rim: Thicker tube (0.04 -> 0.06)
                const rim = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.06, 8, 24), rimMat);
                rim.rotation.y = Math.PI/2;
                wheelGroup.add(rim);
                // Spokes
                const spokeGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.9);
                for(let i=0; i<8; i++) {
                    const spoke = new THREE.Mesh(spokeGeo, rimMat);
                    spoke.rotation.x = (i/8)*Math.PI;
                    spoke.rotation.z = Math.PI/2;
                    wheelGroup.add(spoke);
                }
                return wheelGroup;
            };

            const frontWheel = createWheel();
            frontWheel.position.set(0, 0.45, 0.85); 
            snatcherMesh.add(frontWheel);

            const rearWheel = createWheel();
            rearWheel.position.set(0, 0.45, -0.85);
            snatcherMesh.add(rearWheel);

            // --- FRAME (Thickened) ---
            const frameGroup = new THREE.Group();
            // Thicker bars (0.04 -> 0.05)
            
            // Top Bar
            const topBar = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.7), frameMat);
            topBar.rotation.x = Math.PI/2;
            topBar.position.set(0, 1.05, 0); 
            frameGroup.add(topBar);

            // Down Bar
            const downBar = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.8), frameMat);
            downBar.rotation.x = Math.PI/4;
            downBar.position.set(0, 0.75, 0.3);
            frameGroup.add(downBar);
            
            // Seat Post
            const seatPost = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.2), frameMat);
            seatPost.rotation.x = -Math.PI/6;
            seatPost.position.set(0, 0.8, -0.6);
            frameGroup.add(seatPost);

            // Handlebars
            const handleBar = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8), frameMat);
            handleBar.rotation.z = Math.PI/2;
            handleBar.position.set(0, 1.3, 0.6);
            frameGroup.add(handleBar);

            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.08, 0.5), new THREE.MeshStandardMaterial({color:0x111111}));
            seat.position.set(0, 1.25, -0.7);
            seat.rotation.x = 0.1;
            frameGroup.add(seat);

            snatcherMesh.add(frameGroup);

            // --- THIEF CHARACTER (Proportional) ---
            const hoodieColor = 0x1a1a2e; 
            const hoodieMat = new THREE.MeshStandardMaterial({ color: hoodieColor, roughness: 1.0 }); 

            // Pos: Sitting on bike
            const thief = new THREE.Group();
            thief.position.set(0, 1.3, -0.6); // Sit on seat

            // Torso (Leaning)
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.32, 0.9), hoodieMat);
            torso.rotation.x = Math.PI/3; // More aggressive lean
            torso.position.y = 0.4;
            torso.position.z = 0.3;
            thief.add(torso);

            // Head (Hooded)
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0.8, 0.8);
            
            const hood = new THREE.Mesh(new THREE.SphereGeometry(0.24, 16, 16), hoodieMat);
            headGroup.add(hood);
            
            const face = new THREE.Mesh(new THREE.SphereGeometry(0.16, 16, 16), new THREE.MeshBasicMaterial({color:0x000000}));
            face.position.z = 0.08;
            face.scale.z = 0.8;
            headGroup.add(face);
            thief.add(headGroup);

            // Arms (Reaching)
            const armGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.9);
            const lArm = new THREE.Mesh(armGeo, hoodieMat);
            lArm.position.set(-0.35, 0.6, 0.6);
            lArm.rotation.x = Math.PI/2.2; 
            lArm.rotation.z = -0.3;
            thief.add(lArm);

            const rArm = new THREE.Mesh(armGeo, hoodieMat);
            rArm.position.set(0.35, 0.6, 0.6);
            rArm.rotation.x = Math.PI/2.2;
            rArm.rotation.z = 0.3;
            thief.add(rArm);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.09, 0.09, 1.0);
            const lLeg = new THREE.Mesh(legGeo, new THREE.MeshStandardMaterial({color: 0x111111})); 
            lLeg.position.set(-0.25, 0.0, 0.2);
            lLeg.rotation.x = -Math.PI/3;
            lLeg.rotation.z = -0.1;
            thief.add(lLeg);
            
            const rLeg = new THREE.Mesh(legGeo, new THREE.MeshStandardMaterial({color: 0x111111}));
            rLeg.position.set(0.25, 0.0, 0.2);
            rLeg.rotation.x = -Math.PI/3;
            rLeg.rotation.z = 0.1;
            thief.add(rLeg);

            // Backpack
            const packGeo = new THREE.BoxGeometry(0.4, 0.55, 0.25);
            const packMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pack = new THREE.Mesh(packGeo, packMat);
            pack.position.set(0, 0.5, 0.0); // On Back
            pack.rotation.x = Math.PI/3;
            thief.add(pack);

            snatcherMesh.add(thief);

            snatcherMesh.position.set(0, -100, 0); 
            scene.add(snatcherMesh);
        }




      // --- Advanced Landmark Functions ---

      // 1. LONDON EYE
      let wheelGroup;
      const capsules = [];

      function generateEyeMaterials() {
        const createTex = (drawFn) => {
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          drawFn(ctx, 512, 512);
          const tex = new THREE.CanvasTexture(canvas);
          tex.colorSpace = THREE.SRGBColorSpace;
          return tex;
        };

        return {
          concrete: new THREE.MeshStandardMaterial({
            color: 0x999999,
            roughness: 0.9,
          }),
          steelWhite: new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.5,
          }),
          steelGrey: new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.5,
            metalness: 0.6,
          }),
          glass: new THREE.MeshStandardMaterial({
            color: 0xaaccff,
            roughness: 0.0,
            metalness: 0.9,
            transparent: true,
            opacity: 0.3,
          }),
          capsuleBody: new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.2,
          }),
          cable: new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8,
          }),
        };
      }

      function createLondonEye(x, z) {
        const mats = generateEyeMaterials();
        const eyeGroup = new THREE.Group();
        eyeGroup.position.set(x, 0, z);
        eyeGroup.rotation.y = Math.PI / 2; // Face river

        // Legs
        const legGeo = new THREE.CylinderGeometry(1.5, 3.5, 95, 32);
        const leg1 = new THREE.Mesh(legGeo, mats.steelWhite);
        leg1.position.set(-15, 38, 25);
        leg1.rotation.set(-0.45, 0, -0.18);
        eyeGroup.add(leg1);
        const leg2 = new THREE.Mesh(legGeo, mats.steelWhite);
        leg2.position.set(15, 38, 25);
        leg2.rotation.set(-0.45, 0, 0.18);
        eyeGroup.add(leg2);

        // Wheel
        wheelGroup = new THREE.Group();
        wheelGroup.position.y = 75;
        eyeGroup.add(wheelGroup);

        const radius = 60;
        const ringGeo = new THREE.TorusGeometry(radius, 0.6, 16, 128);
        const outerRing = new THREE.Mesh(ringGeo, mats.steelWhite);
        wheelGroup.add(outerRing);

        // Spokes
        const spokeGeo = new THREE.CylinderGeometry(
          0.05,
          0.05,
          radius * 0.95,
          4
        );
        spokeGeo.translate(0, (radius * 0.95) / 2, 0);
        for (let i = 0; i < 64; i++) {
          const angle = (i / 64) * Math.PI * 2;
          const spoke = new THREE.Mesh(spokeGeo, mats.cable);
          spoke.rotation.z = -angle;
          wheelGroup.add(spoke);
        }

        // Capsules
        const capGeo = new THREE.SphereGeometry(2.5, 32, 16);
        capGeo.scale(1.8, 1.2, 1.2);
        for (let i = 0; i < 32; i++) {
          const angle = (i / 32) * Math.PI * 2;
          const capHolder = new THREE.Group();
          const r = radius + 1;
          capHolder.position.set(Math.cos(angle) * r, Math.sin(angle) * r, 0);
          capHolder.rotation.z = angle;
          wheelGroup.add(capHolder);

          const capsuleMesh = new THREE.Group();
          const shell = new THREE.Mesh(capGeo, mats.glass);
          capsuleMesh.add(shell);
          const floor = new THREE.Mesh(
            new THREE.BoxGeometry(6, 0.2, 3),
            mats.capsuleBody
          );
          floor.position.y = -2;
          capsuleMesh.add(floor);

          capsules.push({ mesh: capsuleMesh, angle: angle });
          capHolder.add(capsuleMesh);
        }
        scene.add(eyeGroup);
      }

      // 2. BIG BEN
      let clockHands = { hours: [], minutes: [] };

      function generateBenMaterials() {
        const createTex = (drawFn) => {
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          drawFn(ctx, 512, 512);
          const tex = new THREE.CanvasTexture(canvas);
          tex.colorSpace = THREE.SRGBColorSpace;
          return tex;
        };
        const brickTex = createTex((ctx, w, h) => {
          ctx.fillStyle = "#C4A484";
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = "#8B4513";
          for (let i = 0; i < 50; i++)
            ctx.fillRect(Math.random() * w, Math.random() * h, 20, 10);
        });
        return {
          stone: new THREE.MeshStandardMaterial({
            map: brickTex,
            roughness: 0.9,
          }),
          gold: new THREE.MeshStandardMaterial({
            color: 0xffd700,
            roughness: 0.2,
            metalness: 0.8,
          }),
          roof: new THREE.MeshStandardMaterial({
            color: 0x445566,
            roughness: 0.7,
          }),
          clockFace: new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffffee,
            emissiveIntensity: 0.2,
          }),
          handMat: new THREE.MeshStandardMaterial({ color: 0x111111 }),
        };
      }

      function createBigBen(x, z) {
        const mats = generateBenMaterials();
        const group = new THREE.Group();
        group.position.set(x, 0, z);

        const shaft = new THREE.Mesh(
          new THREE.BoxGeometry(14, 60, 14),
          mats.stone
        );
        shaft.position.y = 30;
        group.add(shaft);

        const clockHouse = new THREE.Mesh(
          new THREE.BoxGeometry(16, 16, 16),
          mats.stone
        );
        clockHouse.position.y = 60 + 8;
        group.add(clockHouse);

        // Clock Face
        const faceGeo = new THREE.CylinderGeometry(5, 5, 0.5, 32);
        const createFace = (rotY, posX, posZ) => {
          const face = new THREE.Mesh(faceGeo, mats.clockFace);
          face.rotation.z = Math.PI / 2;
          face.rotation.y = rotY;
          face.position.set(posX, 68, posZ);

          const handsPivot = new THREE.Group();
          handsPivot.position.y = 0.3;
          face.add(handsPivot);

          const hourHand = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 5.0, 0.2),
            mats.handMat
          );
          hourHand.position.y = 1.5;
          handsPivot.add(hourHand);
          clockHands.hours.push(hourHand);

          const minHand = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 7.0, 0.2),
            mats.handMat
          );
          minHand.position.y = 2.5;
          minHand.position.z = 0.2;
          handsPivot.add(minHand);
          clockHands.minutes.push(minHand);

          group.add(face);
        };

        createFace(0, 8.1, 0); // Right
        createFace(Math.PI, -8.1, 0); // Left
        createFace(Math.PI / 2, 0, 8.1); // Front
        createFace(-Math.PI / 2, 0, -8.1); // Back

        const roof = new THREE.Mesh(
          new THREE.ConeGeometry(8, 20, 4),
          mats.roof
        );
        roof.position.y = 86;
        roof.rotation.y = Math.PI / 4;
        group.add(roof);

        scene.add(group);
      }

      function updateClock() {
        const now = new Date();
        // London Time roughly
        const hrs = now.getUTCHours() + 1; // BST approx
        const mins = now.getUTCMinutes();
        const secs = now.getUTCSeconds();
        const hRot = -((hrs % 12) + mins / 60) * ((Math.PI * 2) / 12);
        const mRot = -(mins + secs / 60) * ((Math.PI * 2) / 60);

        clockHands.hours.forEach((h) => (h.rotation.z = hRot));
        clockHands.minutes.forEach((m) => (m.rotation.z = mRot));
      }

      function createCity() {
        // --- SOUTH BANK DISTRICTS (Z: 150 to 2500) ---
        // Center at 0, width 1500 covers X: -1500 to 1500
        createCityGrid(0, 1500, 150, 2500); 
        
        // --- NORTH BANK DISTRICTS (Z: -2500 to -150) ---
        createCityGrid(0, 1500, -2500, -150);

        // Add Landmarks
        createLondonEye(-120, -300);
        createBigBen(-200, 250);
        createLandmarks();
      }

      function createLandmarks() {
          createGherkin(80, -350); // North/East
          createWalkieTalkie(150, -280); // North/East
          createStPauls(-50, -400); // North/West
      }

      function createGherkin(x, z) {
          // Bullet shape: Scaled sphere?
          const geo = new THREE.SphereGeometry(25, 16, 16);
          geo.applyMatrix4(new THREE.Matrix4().makeScale(1, 3.5, 1));
          const mat = new THREE.MeshStandardMaterial({
              color: 0x88ccff, // Glassy blue
              metalness: 0.8,
              roughness: 0.2,
              wireframe: false
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(x, 40, z + 60); // Offset to align
          mesh.castShadow = true;
          
          // Diamond pattern (Wireframe overlay)
          const wire = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true, transparent: true, opacity: 0.3 }));
          wire.position.copy(mesh.position);
          
          scene.add(mesh);
          scene.add(wire);
      }

      function createWalkieTalkie(x, z) {
          // Top heavy building.
          // Extrude geometry or just scaled boxes?
          // Let's use a Cylinder with 4 segments (square) and different top/bottom radii
          const geo = new THREE.CylinderGeometry(30, 15, 80, 4);
          geo.rotateY(Math.PI/4); // Align flat sides
          const mat = new THREE.MeshStandardMaterial({
              color: 0xaaccff,
              metalness: 0.5,
              roughness: 0.1
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(x, 40, z);
          // Scale X/Z to be rectangular
          mesh.scale.set(1.5, 1, 1);
          // Curve? Hard to do with simple primitives. This approximation should work for "realistic look" at distance.
          scene.add(mesh);
      }
      
      function createStPauls(x, z) {
          // Dome + Main Body
          const group = new THREE.Group();
          group.position.set(x, 0, z);
          
          // Main Body
          const bodyGeo = new THREE.BoxGeometry(60, 40, 80);
          const stoneMat = new THREE.MeshStandardMaterial({ color: 0xdddddd });
          const body = new THREE.Mesh(bodyGeo, stoneMat);
          body.position.y = 20;
          group.add(body);
          
          // Dome Base (Drum)
          const drumGeo = new THREE.CylinderGeometry(20, 20, 15, 16);
          const drum = new THREE.Mesh(drumGeo, stoneMat);
          drum.position.y = 47.5;
          group.add(drum);
          
          // Dome
          const domeGeo = new THREE.SphereGeometry(20, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
          const domeMat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.2 }); // Lead roof
          const dome = new THREE.Mesh(domeGeo, domeMat);
          dome.position.y = 55;
          group.add(dome);
          
          // Cross/Lantern
          const lanternGeo = new THREE.CylinderGeometry(4, 4, 8);
          const lantern = new THREE.Mesh(lanternGeo, stoneMat);
          lantern.position.y = 75;
          group.add(lantern);

          scene.add(group);
      }

      // ... [OMITTED createCityGrid code] ...

      function createCityGrid(centerX, width, startZ, endZ) {
        const blockSize = 60;
        const length = Math.abs(endZ - startZ);
        
        // Dynamic Texture Repeats for consistency
        const roadTex = createNoiseTexture();
        roadTex.repeat.set(4, length / 6); // Match bridge density
        
        const groundTex = createNoiseTexture();
        groundTex.repeat.set(width * 2 / 5, length / 6); // Approximate density
        const noiseTex = groundTex; // Alias for buildings that use noiseTex

        // Fix Terrain Z-Fighting: Lower ground to -0.6
        const groundGeo = new THREE.BoxGeometry(
          width * 2,
          1,
          length
        );
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0xaaaaaa, // Match bridge sidewalk color
          map: groundTex,
          roughness: 0.9,
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.set(centerX, -0.6, (startZ + endZ) / 2); // Lowered
        
        // Add Road Strips (Main Road in Center)
        const roadWidth = 20;
        const mainRoadGeo = new THREE.BoxGeometry(
          roadWidth,
          1.1,
          length
        );
        const mainRoad = new THREE.Mesh(
          mainRoadGeo,
          new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            roughnessMap: roadTex, // Match bridge road (roughnessMap not map)
            metalness: 0.1,
          })
        );
        mainRoad.position.set(centerX, -0.55, (startZ + endZ) / 2);
        mainRoad.receiveShadow = true;
        scene.add(mainRoad);

        // --- RIVER FRONT WALL (Z-FACE) ---
        // River meeting point is +/- 150
        const riverMeetingZ = startZ > 0 ? Math.min(startZ, endZ) : Math.max(startZ, endZ);
        createZWall(centerX, width, riverMeetingZ);

        // --- RIVER SIDE WALLS (X-SIDES) ---
        // Place precisely at the sidewalk edge (X = +/- 11)
        createRiverWall(startZ, endZ, -11);
        createRiverWall(startZ, endZ, 11);
        
        // Add Ground (Fixed missing add if it was missing, or specific placement)
        scene.add(ground);

        // --- RIVERFRONT PROMENADE: SHOPS, TREES, LAMPS, BENCHES ---
        // Place right at the riverfront edge (riverMeetingZ)
        for (let x = centerX - width + 40; x < centerX + width; x += 30) {
            if (Math.abs(x) < 25) continue;
            
            const zFront = riverMeetingZ + (riverMeetingZ > 0 ? 10 : -10);
            
            if (x % 90 === 0) {
                createRiverfrontShop(x, zFront, riverMeetingZ > 0 ? Math.PI : 0);
            } else if (x % 60 === 0) {
                createCherryBlossomTree(x, zFront);
            } else if (x % 30 === 0) {
                createRiverfrontLampPost(x, zFront);
                createBench(x + 5, zFront, riverMeetingZ > 0 ? Math.PI : 0);
            }
        }

        for (
          let x = centerX - width + blockSize;
          x < centerX + width;
          x += blockSize
        ) {
          for (
            let z = Math.min(startZ, endZ);
            z < Math.max(startZ, endZ);
            z += blockSize
          ) {
            if (Math.abs(x) < 25) continue;

            // --- EXCLUSION ZONES FOR LANDMARKS ---
            // London Eye: (-100, -250), Radius ~150
            const dxEye = x - -100;
            const dzEye = z - -250;
            if (dxEye*dxEye + dzEye*dzEye < 150*150) continue;

            // Big Ben: (-200, 200), Radius ~80
            const dxBen = x - -200;
            const dzBen = z - 200;
            if (dxBen*dxBen + dzBen*dzBen < 80*80) continue;

            // Future Landmarks (Placeholders)
            // Gherkin: (300, -400)
            const dxGherk = x - 300;
            const dzGherk = z - -400;
            if (dxGherk*dxGherk + dzGherk*dzGherk < 80*80) continue;

             // St Pauls: (200, 400)
            const dxPaul = x - 200;
            const dzPaul = z - 400;
            if (dxPaul*dxPaul + dzPaul*dzPaul < 120*120) continue;
            
            // Walkie Talkie: (400, -200)
             const dxWalk = x - 400;
            const dzWalk = z - -200;
             if (dxWalk*dxWalk + dzWalk*dzWalk < 80*80) continue;

            // --- RIVERFRONT SHOPS AND TREES ---
            if (Math.abs(x) < 60) {
                // If we are near the riverfront, add shops and trees
                if (z % 80 === 0) {
                    createRiverfrontShop(x, z, x > 0 ? -Math.PI / 2 : Math.PI / 2);
                } else if (z % 40 === 0) {
                    createCherryBlossomTree(x + (x > 0 ? -10 : 10), z);
                }
                continue; // Skip building generation for this spot to keep it airy
            }


            // MORE GARDENS: Increased chance from 0.2 to 0.4
            if (Math.random() < 0.4) {
              const parkGeo = new THREE.BoxGeometry(
                blockSize - 5,
                1.2,
                blockSize - 5
              );
              // Vibrant Grass Green
              const park = new THREE.Mesh(
                parkGeo,
                new THREE.MeshStandardMaterial({
                  color: 0x33cc33,
                  roughness: 1.0,
                })
              );
              park.position.set(x, -0.4, z);
              scene.add(park);

              // Dense Forest in Parks
              const treeCount = Math.floor(Math.random() * 5) + 3;
              for (let t = 0; t < treeCount; t++) {
                const tx = x + (Math.random() - 0.5) * (blockSize - 10);
                const tz = z + (Math.random() - 0.5) * (blockSize - 10);

                // Mix of regular and Cherry Blossom trees
                if (Math.random() < 0.6) createCherryBlossomTree(tx, tz);
                else createRealisticTree(tx, tz);
              }
            } else {
              // BUILDINGS + SIDEWALK TREES
              const height = 20 + Math.random() * 80;
              const buildingGeo = new THREE.BoxGeometry(
                blockSize - 10,
                height,
                blockSize - 10
              );
              const hue = Math.random() * 0.1 + 0.55;
              const isGlass = Math.random() > 0.7;

              let buildingMat;
              if (isGlass) {
                buildingMat = new THREE.MeshStandardMaterial({
                  color: new THREE.Color().setHSL(0.6, 0.4, 0.2),
                  metalness: 0.8,
                  roughness: 0.1,
                  transparent: true,
                  opacity: 0.7,
                });
              } else {
                buildingMat = new THREE.MeshStandardMaterial({
                  color: new THREE.Color().setHSL(
                    hue,
                    0.2,
                    0.2 + Math.random() * 0.2
                  ),
                  map: noiseTex,
                  roughness: 0.8,
                });
              }

              const building = new THREE.Mesh(buildingGeo, buildingMat);
              building.position.set(x, height / 2 - 0.5, z);
              building.castShadow = true;
              building.receiveShadow = true;
              scene.add(building);

              // Add glowing windows for night/dusk vibe
              if (!isGlass && Math.random() > 0.5) {
                const winGeo = new THREE.BoxGeometry(
                  blockSize - 10.5,
                  height - 4,
                  blockSize - 10.5
                );
                const winMat = new THREE.MeshBasicMaterial({
                  color: 0xffaa00,
                  wireframe: true,
                  transparent: true,
                  opacity: 0.05,
                });
                const wins = new THREE.Mesh(winGeo, winMat);
                wins.position.copy(building.position);
                scene.add(wins);
              }

              // SIDEWALK TREES: Add trees to the street corners of building blocks
              if (Math.random() < 0.7) {
                // High chance for street trees
                // Place near the road (Z +/- blockSize/2)
                const side = Math.random() > 0.5 ? 1 : -1;
                const tz = z + (blockSize / 2 - 2) * side;
                // Avoid placing inside building (Building width is blockSize-10, so boundary is blockSize/2 - 5)
                // We place slightly outside
                createRealisticTree(x + (Math.random() - 0.5) * 10, tz);
              }
            }
          }
        }
      }

      function createRailing(x, length) {
        const postGeo = new THREE.BoxGeometry(0.5, 1.5, 0.5);
        const postMat = new THREE.MeshStandardMaterial({ color: 0x223344 });
        const railGeo = new THREE.BoxGeometry(0.3, 0.3, length);
        const rail = new THREE.Mesh(railGeo, postMat);
        rail.position.set(x, 1.5, 0);
        scene.add(rail);
        for (let z = -length / 2; z <= length / 2; z += 5) {
          const post = new THREE.Mesh(postGeo, postMat);
          post.position.set(x, 0.75, z);
          scene.add(post);
        }
      }

      function createTower(x, y, z) {
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0xe0d8c0 });
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x5a7ca6 });
        const group = new THREE.Group();
        group.position.set(x, y, z);

        // Extend bases deep into river (Adjusted for deeper water at -16)
        const baseLeft = new THREE.Mesh(
          new THREE.BoxGeometry(6, 40, 10),
          stoneMat
        );
        baseLeft.position.set(-10, -15, 0); // Top at +5, Bottom at -35
        baseLeft.castShadow = true;
        group.add(baseLeft);

        const baseRight = new THREE.Mesh(
          new THREE.BoxGeometry(6, 40, 10),
          stoneMat
        );
        baseRight.position.set(10, -15, 0);
        baseRight.castShadow = true;
        group.add(baseRight);

        const archTop = new THREE.Mesh(
          new THREE.BoxGeometry(26, 4, 10),
          stoneMat
        );
        archTop.position.set(0, 15, 0);
        archTop.castShadow = true;
        group.add(archTop);
        const towerBodyL = new THREE.Mesh(
          new THREE.BoxGeometry(5, 25, 8),
          stoneMat
        );
        towerBodyL.position.set(-10, 10, 0);
        group.add(towerBodyL);
        const towerBodyR = new THREE.Mesh(
          new THREE.BoxGeometry(5, 25, 8),
          stoneMat
        );
        towerBodyR.position.set(10, 10, 0);
        group.add(towerBodyR);
        const roofGeo = new THREE.ConeGeometry(4, 10, 4);
        const roofL = new THREE.Mesh(roofGeo, roofMat);
        roofL.position.set(-10, 27, 0);
        roofL.rotation.y = Math.PI / 4;
        group.add(roofL);
        const roofR = new THREE.Mesh(roofGeo, roofMat);
        roofR.position.set(10, 27, 0);
        roofR.rotation.y = Math.PI / 4;
        group.add(roofR);
        scene.add(group);
      }

      function createCables() {
        const cableMat = new THREE.MeshStandardMaterial({ color: 0x446688 });
        const addCable = (start, end) => {
          const distance = start.distanceTo(end);
          const geometry = new THREE.CylinderGeometry(0.1, 0.1, distance, 8);
          const mesh = new THREE.Mesh(geometry, cableMat);
          const mid = new THREE.Vector3()
            .addVectors(start, end)
            .multiplyScalar(0.5);
          mesh.position.copy(mid);
          mesh.lookAt(end);
          mesh.rotateX(Math.PI / 2);
          scene.add(mesh);
        };
        const t1Left = new THREE.Vector3(-10, 20, 60);
        const t1Right = new THREE.Vector3(10, 20, 60);
        const t2Left = new THREE.Vector3(-10, 20, -60);
        const t2Right = new THREE.Vector3(10, 20, -60);
        const end1Left = new THREE.Vector3(-10, 0, 150);
        const end1Right = new THREE.Vector3(10, 0, 150);
        const end2Left = new THREE.Vector3(-10, 0, -150);
        const end2Right = new THREE.Vector3(10, 0, -150);
        addCable(t1Left, t2Left);
        addCable(t1Right, t2Right);
        addCable(t1Left, end1Left);
        addCable(t1Right, end1Right);
        addCable(t2Left, end2Left);
        addCable(t2Right, end2Right);
      }

      function createLampPost(x, z) {
        const group = new THREE.Group();
        group.position.set(x, 0, z);
        const poleGeo = new THREE.CylinderGeometry(0.1, 0.2, 4);
        const poleMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.y = 2;
        group.add(pole);
        const housingGeo = new THREE.BoxGeometry(0.6, 0.8, 0.6);
        const housingMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const housing = new THREE.Mesh(housingGeo, housingMat);
        housing.position.y = 4.2;
        group.add(housing);
        const bulbGeo = new THREE.SphereGeometry(0.2);
        const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.y = 4.2;
        group.add(bulb);
        scene.add(group);
      }

      // --- BOATS (Paper Origami Style) ---
      let boatMeshes = [];

      function createBoats() {
        // Paper Boat Helper
        const createPaperBoat = () => {
          const group = new THREE.Group();
          const whitePaper = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.9,
            side: THREE.DoubleSide,
          });

          // 1. Hull (Inverted Pyramid / Boat shape)
          // Use a cone with 4 segments (pyramid), inverted and flattened
          const hullGeo = new THREE.ConeGeometry(10, 8, 4);
          hullGeo.rotateZ(Math.PI); // Point down
          hullGeo.scale(2.5, 0.5, 1); // Flatten and elongate
          const hull = new THREE.Mesh(hullGeo, whitePaper);
          hull.position.y = 2;
          hull.rotation.y = Math.PI / 4; // Align flat side
          hull.castShadow = true;
          group.add(hull);

          // 2. Central Sail / Triangle
          const sailGeo = new THREE.ConeGeometry(8, 12, 4);
          sailGeo.scale(1.5, 1, 0.2); // Flat triangle
          const sail = new THREE.Mesh(sailGeo, whitePaper);
          sail.position.y = 6;
          sail.rotation.y = Math.PI / 4;
          sail.castShadow = true;
          group.add(sail);

          return group;
        };

        // Spawn Logic
        for (let i = 0; i < 15; i++) {
          // Increased count slightly
          const boat = createPaperBoat();

          // PLACEMENT
          let zPos = (Math.random() - 0.5) * 200;
          const lane = Math.random();
          if (lane < 0.5) zPos = (Math.random() - 0.5) * 80;
          else if (lane < 0.75) zPos = -100 + Math.random() * 20;
          else zPos = 100 + Math.random() * 20;

          const xPos = (Math.random() - 0.5) * 2000;

          // Height: -16.5 to sit in water (Water at -16)
          boat.position.set(xPos, -16.5, zPos);

          const dir = Math.random() > 0.5 ? 1 : -1;
          boat.userData = { speed: (Math.random() * 5 + 3) * dir };

          // Rotation: Align with movement
          if (dir === 1) boat.rotation.y = 0;
          else boat.rotation.y = Math.PI;

          scene.add(boat);
          boatMeshes.push(boat);
        }
      }

      function createRealisticTree(x, z) {
        const group = new THREE.Group();
        group.position.set(x, 0.4, z);
        const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, 2.5, 6);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1.25;
        trunk.castShadow = true;
        group.add(trunk);
        const leafMat = new THREE.MeshStandardMaterial({
          color: 0xffafcc,
          flatShading: true,
          roughness: 1,
        });
        const leafPositions = [
          { x: 0, y: 3, z: 0, s: 1.5 },
          { x: 0.8, y: 2.5, z: 0.5, s: 1.0 },
          { x: -0.8, y: 2.6, z: -0.5, s: 1.1 },
          { x: 0.5, y: 3.2, z: -0.8, s: 0.9 },
          { x: -0.5, y: 2.8, z: 0.8, s: 1.0 },
        ];
        leafPositions.forEach((pos) => {
          const geo = new THREE.DodecahedronGeometry(pos.s);
          const mesh = new THREE.Mesh(geo, leafMat);
          mesh.position.set(pos.x, pos.y, pos.z);
          mesh.castShadow = false; // OPTIMIZATION: Leaves don't cast shadows
          group.add(mesh);
        });
        scene.add(group);
      }

      function createRiverfrontShop(x, z, rotationY) {
          const group = new THREE.Group();
          group.position.set(x, 0, z);
          group.rotation.y = rotationY;

          // Main Building
          const bodyGeo = new THREE.BoxGeometry(15, 12, 12);
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 6;
          body.castShadow = true;
          group.add(body);

          // Storefront Glass
          const glassGeo = new THREE.PlaneGeometry(12, 8);
          const glassMat = new THREE.MeshStandardMaterial({ 
              color: 0x88ccff, 
              transparent: true, 
              opacity: 0.6,
              roughness: 0,
              metalness: 0.5
          });
          const glass = new THREE.Mesh(glassGeo, glassMat);
          glass.position.set(0, 5, 6.01); // Slightly in front
          group.add(glass);

          // Shop Sign
          const signGeo = new THREE.BoxGeometry(10, 2, 0.5);
          const signMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
          const sign = new THREE.Mesh(signGeo, signMat);
          sign.position.set(0, 10, 6.2);
          group.add(sign);

          // Awning
          const awningGeo = new THREE.BoxGeometry(14, 0.5, 4);
          const awningMat = new THREE.MeshStandardMaterial({ color: Math.random() < 0.5 ? 0xff4444 : 0x4444ff });
          const awning = new THREE.Mesh(awningGeo, awningMat);
          awning.position.set(0, 9, 8);
          awning.rotation.x = Math.PI / 6;
          group.add(awning);

          // --- BULB DECORATIONS ---
          const bulbGeo = new THREE.SphereGeometry(0.15, 8, 8);
          const bulbMat = new THREE.MeshStandardMaterial({ 
              color: 0xffffcc,
              emissive: 0xffffcc,
              emissiveIntensity: 1.0
          });
          for (let i = -6; i <= 6; i += 1.5) {
              const bulb = new THREE.Mesh(bulbGeo, bulbMat);
              bulb.position.set(i, 8.5, 9.5);
              // bulb.castShadow = false; // Implicit default is false, but ensuring NO shadows
              group.add(bulb);
          }

          // --- SIDE BRICK PATIO (ENTRANCE) ---
          const patioGeo = new THREE.BoxGeometry(16, 0.2, 10);
          const brickTex = createBrickTexture();
          brickTex.repeat.set(4, 2);
          const patioMat = new THREE.MeshStandardMaterial({ map: brickTex });
          const patio = new THREE.Mesh(patioGeo, patioMat);
          patio.position.set(0, -0.4, 8);
          group.add(patio);

          scene.add(group);

          // Add some NPCs near the shop entrance
          for (let i = 0; i < 3; i++) {
              const shirtColor = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
              const npc = createRealisticHuman(shirtColor);
              const npcX = x + (Math.random() - 0.5) * 10;
              const npcZ = z + 12 + Math.random() * 5;
              npc.position.set(npcX, 0, npcZ);
              npc.rotation.y = Math.random() * Math.PI * 2;
              scene.add(npc);
              
              people.push({
                  group: npc,
                  speed: 0, // Stationery NPCs
                  dir: 1,
                  side: 1
              });
          }
      }

      function createRiverWall(zStart, zEnd, xPos) {
          const length = Math.abs(zEnd - zStart);
          const wallGeo = new THREE.PlaneGeometry(length, 16); // Height 16 (to -16)
          const brickTex = createBrickTexture();
          brickTex.repeat.set(length / 4, 4);
          
          const wallMat = new THREE.MeshStandardMaterial({ 
              map: brickTex,
              roughness: 0.8
          });
          const wall = new THREE.Mesh(wallGeo, wallMat);
          
          wall.position.set(xPos, -8.6, (zStart + zEnd) / 2);
          wall.rotation.y = xPos > 0 ? -Math.PI / 2 : Math.PI / 2;
          scene.add(wall);
      }

      function createZWall(xCenter, width, zPos) {
          const wallGeo = new THREE.PlaneGeometry(width * 2, 16);
          const brickTex = createBrickTexture();
          brickTex.repeat.set(width / 2, 4);
          
          const wallMat = new THREE.MeshStandardMaterial({ 
              map: brickTex, 
              roughness: 0.8 
          });
          const wall = new THREE.Mesh(wallGeo, wallMat);
          
          wall.position.set(xCenter, -8.6, zPos);
          // Rotation: If zPos > 0, face Z-neg (towards river). If zPos < 0, face Z-pos.
          wall.rotation.y = zPos > 0 ? Math.PI : 0;
          scene.add(wall);
      }

      function createBench(x, z, rot) {
          const group = new THREE.Group();
          group.position.set(x, 0, z);
          group.rotation.y = rot;
          
          const woodMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
          const legGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
          const seatGeo = new THREE.BoxGeometry(3, 0.1, 1);
          const backGeo = new THREE.BoxGeometry(3, 0.8, 0.1);
          
          const seat = new THREE.Mesh(seatGeo, woodMat);
          seat.position.y = 0.8;
          group.add(seat);
          
          const back = new THREE.Mesh(backGeo, woodMat);
          back.position.set(0, 1.2, -0.45);
          group.add(back);
          
          const legs = [[-1.3, 0.4, 0.4], [1.3, 0.4, 0.4], [-1.3, 0.4, -0.4], [1.3, 0.4, -0.4]];
          legs.forEach(p => {
              const leg = new THREE.Mesh(legGeo, woodMat);
              leg.position.set(...p);
              group.add(leg);
          });
          
          scene.add(group);
      }

      function createRiverfrontLampPost(x, z) {
          const group = new THREE.Group();
          group.position.set(x, 0, z);
          
          const metalMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
          const postGeo = new THREE.CylinderGeometry(0.1, 0.15, 6, 8);
          const post = new THREE.Mesh(postGeo, metalMat);
          post.position.y = 3;
          group.add(post);
          
          const lampGeo = new THREE.SphereGeometry(0.4);
          const lampMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
          const lamp = new THREE.Mesh(lampGeo, lampMat);
          lamp.position.y = 6.2;
          group.add(lamp);
          
          scene.add(group);
      }

      // --- REALISTIC HUMANS ---
      function createRealisticHuman(color) {
        const group = new THREE.Group();
        const skinColor = 0xffdbac; // Basic skin tone
        
        const hasJacket = Math.random() > 0.5;
        const jacketColor = new THREE.Color().setHSL(Math.random(), 0.3, 0.2); // Darker tones

        // Materials
        const shirtMat = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.9,
        });
        const jacketMat = new THREE.MeshStandardMaterial({
          color: jacketColor,
          roughness: 0.8,
        });
        const pantMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          roughness: 0.9,
        });
        const skinMat = new THREE.MeshStandardMaterial({
          color: skinColor,
          roughness: 0.5,
        });

        // 1. Torso
        const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.25);
        const torso = new THREE.Mesh(torsoGeo, shirtMat);
        torso.position.y = 1.15; // Center height
        torso.castShadow = true;
        group.add(torso);

        if (hasJacket) {
            const jTorsoGeo = new THREE.BoxGeometry(0.56, 0.75, 0.3);
            const jTorso = new THREE.Mesh(jTorsoGeo, jacketMat);
            jTorso.position.y = 1.15;
            group.add(jTorso);
        }

        // 2. Head
        const headGeo = new THREE.BoxGeometry(0.25, 0.3, 0.25);
        const head = new THREE.Mesh(headGeo, skinMat);
        head.position.y = 1.65;
        head.castShadow = true;
        group.add(head);

        // 3. Arms (Pivots for animation)
        const armGeo = new THREE.BoxGeometry(0.12, 0.7, 0.12);
        const armMat = hasJacket ? jacketMat : shirtMat;

        // Left Arm
        const lArm = new THREE.Mesh(armGeo, armMat);
        lArm.position.set(-0.35, 1.3, 0);
        const lArmPivot = new THREE.Group();
        lArmPivot.position.set(-0.35, 1.45, 0); // Shoulder pos
        lArm.position.set(0, -0.3, 0); // Offset geometry
        lArmPivot.add(lArm);
        group.add(lArmPivot);

        // Right Arm
        const rArm = new THREE.Mesh(armGeo, armMat);
        const rArmPivot = new THREE.Group();
        rArmPivot.position.set(0.35, 1.45, 0);
        rArm.position.set(0, -0.3, 0);
        rArmPivot.add(rArm);
        group.add(rArmPivot);

        // 4. Legs
        const legGeo = new THREE.BoxGeometry(0.18, 0.75, 0.18);

        // Left Leg
        const lLeg = new THREE.Mesh(legGeo, pantMat);
        const lLegPivot = new THREE.Group();
        lLegPivot.position.set(-0.15, 0.75, 0); // Hip pos
        lLeg.position.set(0, -0.35, 0); // Offset geometry
        lLegPivot.add(lLeg);
        group.add(lLegPivot);

        // Right Leg
        const rLeg = new THREE.Mesh(legGeo, pantMat);
        const rLegPivot = new THREE.Group();
        rLegPivot.position.set(0.15, 0.75, 0); // Hip pos
        rLeg.position.set(0, -0.35, 0);
        rLegPivot.add(rLeg);
        group.add(rLegPivot);

        // Store references for animation
        group.userData = {
          lArm: lArmPivot,
          rArm: rArmPivot,
          lLeg: lLegPivot,
          rLeg: rLegPivot,
        };
        return group;
      }

      function createCrowd() {
        // Significantly increased crowd count
        for (let i = 0; i < 500; i++) {
          const shirtColor = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
          const person = createRealisticHuman(shirtColor);

          const side = Math.random() > 0.5 ? 1 : -1;
          // Position: 8.5 is bridge sidewalk. City sidewalk might be wider/different.
          // Bridge width constraint: +/- 8.5 approx.
          // City width constraint: Road is wider?
          // Let's keep them on a "sidewalk" line for now.
          const xPos = (8.5 + (Math.random() - 0.5) * 4) * side;

          // Extended Range: -2000 to 2000
          const zPos = (Math.random() - 0.5) * 4000;

          person.position.set(xPos, 0, zPos);

          const speed = 0.05 + Math.random() * 0.05;
          const direction = Math.random() > 0.5 ? 1 : -1;
          
          people.push({
            group: person,
            speed: speed,
            dir: direction,
            side: side
          });
          scene.add(person);
        }
      }

      // --- TRAFFIC ---
      let busMeshes = [];

      function createBus() {
        // Create Multiple Buses
        const busCount = 6;
        const busGeo = new THREE.BoxGeometry(2.6, 4.4, 10);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0xcc0000,
          roughness: 0.2,
        });
        const winMat = new THREE.MeshStandardMaterial({
          color: 0x88ccff,
          roughness: 0.1,
        });
        const lowerWinGeo = new THREE.BoxGeometry(2.7, 1, 9);
        const upperWinGeo = new THREE.BoxGeometry(2.7, 1, 9);
        const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 2.8, 12);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        for (let i = 0; i < busCount; i++) {
          const group = new THREE.Group();

          const body = new THREE.Mesh(busGeo, bodyMat);
          body.position.y = 3;
          group.add(body);

          const lowerWin = new THREE.Mesh(lowerWinGeo, winMat);
          lowerWin.position.y = 2.5;
          group.add(lowerWin);

          const upperWin = new THREE.Mesh(upperWinGeo, winMat);
          upperWin.position.y = 4.2;
          group.add(upperWin);

          const w1 = new THREE.Mesh(wheelGeo, wheelMat);
          w1.position.set(0, 0.8, 2.5);
          const w2 = new THREE.Mesh(wheelGeo, wheelMat);
          w2.position.set(0, 0.8, -2.5);
          group.add(w1);
          group.add(w2);

          // Start Positions
          // South Bank: -300 to -1000
          // North Bank: 300 to 1000
          // Bridge: -150 to 150
          const zStart =
            Math.random() > 0.5
              ? 200 + Math.random() * 800
              : -200 - Math.random() * 800;

          group.position.set(-3, 0, zStart);

          // Randomize speed slightly
          group.userData = { speed: 0.3 + Math.random() * 0.2 };

          scene.add(group);
          busMeshes.push(group);
        }
      }

      // --- NEON CITY ---
      let neonGroup;
      function createNeonCity() {
        neonGroup = new THREE.Group();
        const colors = [0xff00ff, 0x00ffff, 0x00ff00, 0xffaa00];
        const geo = new THREE.BoxGeometry(2, 8, 0.5);

        for (let i = 0; i < 300; i++) {
          // Increased count for larger city
          const color = colors[Math.floor(Math.random() * colors.length)];
          const mat = new THREE.MeshBasicMaterial({ color: color });
          const mesh = new THREE.Mesh(geo, mat);

          // Random Grid Position (Approximate city blocks)
          const x = (Math.floor(Math.random() * 20) - 10) * 40;
          let z = (Math.floor(Math.random() * 60) - 30) * 40; // Wider Z spawn

          // Avoid river (approx Z=-50 to 50?)
          if (Math.abs(z) < 60) continue;

          mesh.position.set(
            x + (Math.random() - 0.5) * 30,
            15 + Math.random() * 20,
            z + (Math.random() - 0.5) * 30
          );

          // Rotate to face streets
          mesh.rotation.y = Math.random() > 0.5 ? 0 : Math.PI / 2;

          neonGroup.add(mesh);
        }
        scene.add(neonGroup);
      }

      function createFallingPetals() {
        const petalGeo = new THREE.PlaneGeometry(0.1, 0.1);
        const petalMat = new THREE.MeshBasicMaterial({
          color: 0xffb7c5,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.8,
        });

        for (let i = 0; i < 1000; i++) {
          const petal = new THREE.Mesh(petalGeo, petalMat);
          resetPetal(petal);
          scene.add(petal);
          petals.push({
            mesh: petal,
            speed: 0.5 + Math.random() * 1.5,
            sway: Math.random() * 0.1,
          });
        }
      }

      function resetPetal(petal) {
        petal.position.set(
          (Math.random() - 0.5) * 400,
          50 + Math.random() * 50, // Start high up
          (Math.random() - 0.5) * 400
        );
        petal.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
      }

      function createDaffodils() {
        const count = 3000;
        const dummy = new THREE.Object3D();

        // 1. Stems Instanced Mesh
        const stemGeo = new THREE.PlaneGeometry(0.05, 0.5);
        const stemMat = new THREE.MeshBasicMaterial({
          color: 0x228b22,
          side: THREE.DoubleSide,
        });
        const stemMesh = new THREE.InstancedMesh(stemGeo, stemMat, count);

        // 2. Flowers Instanced Mesh
        const flowerGeo = new THREE.CircleGeometry(0.15, 6);
        const flowerMat = new THREE.MeshBasicMaterial({
          color: 0xffd700,
          side: THREE.DoubleSide,
        });
        const flowerMesh = new THREE.InstancedMesh(flowerGeo, flowerMat, count);

        let index = 0;

        // Scatter along the river banks
        for (let i = 0; i < 3000; i++) {
          const x = (Math.random() - 0.5) * 800;
          // Keep away from center (River is approx width 100)
          if (Math.abs(x) < 60) continue;

          // Z range: banks are typically along Z axis in this world setup?
          // Previous logic: z = (Math.random() > 0.5) ? (160 + ...) : (-160 - ...)
          // Wait, River is usually along X or Z. createRiver() usually makes a plane.
          // Assuming previous logic was correct for placement.
          const z =
            Math.random() > 0.5
              ? 160 + Math.random() * 100
              : -160 - Math.random() * 100;

          // Stem transform
          dummy.position.set(x, 0.25, z);
          dummy.rotation.set(0, Math.random() * Math.PI, 0);
          dummy.scale.set(1, 1, 1);
          dummy.updateMatrix();
          stemMesh.setMatrixAt(index, dummy.matrix);

          // Flower transform (relative to stem logic, but global here)
          // Flower is at tip of stem. Stem is 0.5 high, center at 0.25. Top is at 0.5.
          // Flower position: x, 0.5, z (slightly offset for variation)

          // We must match the rotation of the stem for the flower to look attached
          // Actually easier: Just place flower at top location
          dummy.position.set(x, 0.5, z);
          // Face slightly up/forward
          dummy.rotation.x = -0.5;
          dummy.updateMatrix();
          flowerMesh.setMatrixAt(index, dummy.matrix);

          index++;
        }

        stemMesh.instanceMatrix.needsUpdate = true;
        flowerMesh.instanceMatrix.needsUpdate = true;

        // Optimization: Frustum culling can be tricky with large bounds,
        // but for now default is fine.
        scene.add(stemMesh);
        scene.add(flowerMesh);
      }

      function animatePetals() {
        petals.forEach((p) => {
          p.mesh.position.y -= p.speed * 0.1;
          p.mesh.position.x +=
            Math.sin(Date.now() * 0.001 + p.mesh.position.y) * p.sway;
          p.mesh.position.z +=
            Math.cos(Date.now() * 0.0005 + p.mesh.position.y) * p.sway;
          p.mesh.rotation.y += 0.02;
          p.mesh.rotation.z += 0.02;

          if (p.mesh.position.y < -1) {
            resetPetal(p.mesh);
          }
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight); // Ensure Composer Resizes too
      }

      function animate() {
        requestAnimationFrame(animate);

        if (gameEnded) return;

        const time = performance.now();
        // Cap delta to 0.1s (10 FPS min) to prevent huge jumps on tab switch or lag
        const rawDelta = (time - prevTime) / 1000;
        const delta = Math.min(rawDelta, 0.1);

        if (controls.isLocked || isMobile) {
          // Stamina Logic
          const isMoving = moveForward || moveBackward || moveLeft || moveRight;
          let actualSpeed = 80.0; // Base walk speed

          if (isSprinting && stamina > 0 && isMoving) {
            actualSpeed = 160.0; // Reduced from 280.0 for better control
            stamina -= sprintCost * delta;
            if (stamina < 0) stamina = 0;
          } else {
            if (stamina < maxStamina) {
              stamina += regenRate * delta;
            }
          }

          // Update Stamina UI (Removed as HUD element is gone)
          /* 
          document.getElementById("stamina-bar").style.width = stamina + "%";
          if (stamina < 20)
            document.getElementById("stamina-bar").style.background = "#ff4444";
          else
            document.getElementById("stamina-bar").style.background =
              "linear-gradient(90deg, #00ff88, #00ccff)";
          */

          // Physics
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          velocity.y -= 9.8 * 10.0 * delta;

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();

          if (moveForward || moveBackward)
            velocity.z -= direction.z * actualSpeed * delta;
          if (moveLeft || moveRight)
            velocity.x -= direction.x * actualSpeed * delta;

          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);

          // --- BRIDGE BOUNDARY ---
          // Bridge spans approx -160 to 160 on Z. Railings are at +/- 10.5.
          if (camera.position.z > -160 && camera.position.z < 160) {
            const limitX = 9.8;
            if (camera.position.x > limitX) camera.position.x = limitX;
            if (camera.position.x < -limitX) camera.position.x = -limitX;
          }

          if (camera.position.y < 1.6) {
            velocity.y = 0;
            camera.position.y = 1.6;
            canJump = true;
          }

          // --- FOOTSTEP AUDIO ---
          if (gameStarted && !gameEnded && isMoving && camera.position.y <= 1.6 + 0.1) {
            if (isSprinting && stamina > 0) {
              if (walkSound && walkSound.isPlaying) walkSound.stop();
              if (runSound && !runSound.isPlaying) runSound.play();
            } else {
              if (runSound && runSound.isPlaying) runSound.stop();
              if (walkSound && !walkSound.isPlaying) walkSound.play();
            }
          } else {
            if (walkSound && walkSound.isPlaying) walkSound.stop();
            if (runSound && runSound.isPlaying) runSound.stop();
          }
        } else {
             // TITLE ANIMATION REMOVED (Static Title)
        }

        // Snatcher Logic
        if (gameStarted) {
          // He moves in Negative Z (towards the city/south)
          snatcherMesh.position.z -= snatcherSpeed * delta;

          if (phoneSnatched && snatchActive) { // Only check if active
            const dist = snatcherMesh.position.distanceTo(camera.position);

            // Update HUD Distance
            document.getElementById("dist-val").innerText =
              Math.round(dist) + "m";

            // Update Thief Marker Position
            const marker = document.getElementById("thief-marker");

            // Check if thief is in front of camera to show marker
            const snatcherPos = snatcherMesh.position.clone();
            snatcherPos.y += 3; // Position above head
            snatcherPos.project(camera); // Convert to screen space

            // Only show if in front of camera (z < 1) and game isn't over
            if (snatcherPos.z < 1) {
              const x = (snatcherPos.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-(snatcherPos.y * 0.5) + 0.5) * window.innerHeight;
              marker.style.display = "block";
              marker.style.left = x + "px";
              marker.style.top = y + "px";

              // Scale marker based on distance
              const scale = Math.max(0.6, 1 - dist / 150);
              marker.style.transform = `translate(-50%, -100%) scale(${scale})`;
              marker.style.opacity = Math.max(0.5, 1 - dist / 200);
            } else {
              marker.style.display = "none";
            }

            // WIN CONDITION
            if (dist < 3.5 && canBeCaught) {
              endGame(true);
              return;
            }
            // LOSE CONDITION: Triggered when thief is too far
            if (dist > 150) {
              endGame(false);
              return;
            } else if (dist > 100) {
              const alert = document.getElementById("alert-msg");
              alert.innerText = "THIEF ESCAPING! SPRINT!";
              alert.style.color = "#ffaa00";
            } else {
              const alert = document.getElementById("alert-msg");
              alert.innerText = "PHONE STOLEN!"; // Reset
              alert.style.color = "#ff3333";
            }

            // CHASE AI
            if (dist < 15) {
              // PANIC: Player is too close! Sprint! (Speed reduced to be slower than player sprint)
              snatcherSpeed = 26;
            } else if (dist > 60) {
              // RELAX: Player is far behind, slow down to taunt/rest
              if (snatcherSpeed > 15) snatcherSpeed -= 10 * delta;
            } else {
              // CRUISING: Gradually accelerate up to a max cruising speed (reduced)
              if (snatcherSpeed < 24) {
                snatcherSpeed += 2.0 * delta;
              }
            }
          }
        }

        // Environment Animation
        animatePetals();
        if (waterMesh && waterMesh.material.uniforms) {
          waterMesh.material.uniforms["time"].value += 1.0 / 60.0;
        }

        people.forEach((p) => {
          // Move Forward
          p.group.position.z += p.speed * p.dir;
          p.group.rotation.y = p.dir > 0 ? 0 : Math.PI;

          // Bound Check
          if (p.group.position.z > 400) p.dir = -1;
          if (p.group.position.z < -400) p.dir = 1;

          // Walk Cycle Animation
          const walkSpeed = time * 0.01;
          const limbAmp = 0.5; // Swing amplitude

          if (p.group.userData.lLeg) {
            p.group.userData.lLeg.rotation.x = Math.sin(walkSpeed) * limbAmp;
            p.group.userData.rLeg.rotation.x =
              Math.sin(walkSpeed + Math.PI) * limbAmp;

            p.group.userData.lArm.rotation.x =
              Math.sin(walkSpeed + Math.PI) * limbAmp;
            p.group.userData.rArm.rotation.x = Math.sin(walkSpeed) * limbAmp;

            // Bobbing
            p.group.position.y = Math.abs(Math.sin(walkSpeed * 2)) * 0.05;
          }
        });

        // Animate Buses (New System)
        if (busMeshes && busMeshes.length > 0) {
          busMeshes.forEach((bus) => {
            bus.position.z += bus.userData.speed;
            // Wrap around logic
            if (bus.position.z > 1200) bus.position.z = -1200;
            if (bus.position.z < -1200) bus.position.z = 1200;
          });
        }

        // Animate Boats (X Axis Movement)
        boatMeshes.forEach((boat) => {
          boat.position.x += boat.userData.speed * delta;

          // Wrap around logic (River Length approx 2000)
          if (boat.position.x > 1000) boat.position.x = -1000;
          if (boat.position.x < -1000) boat.position.x = 1000;

          // Bobbing (Y Axis)
          boat.position.y =
            -16.5 + Math.sin(time * 0.5 + boat.position.x * 0.05) * 0.2;

          // Slight rolling for realism
          boat.rotation.z =
            Math.sin(time * 0.3 + boat.position.x * 0.01) * 0.02;
        });

        // Landmark Animations
        if (wheelGroup) {
          wheelGroup.rotation.z -= 0.0005; // Slow rotation
          capsules.forEach((cap) => {
            // Counter-rotate capsules to keep them upright
            cap.mesh.rotation.z = -wheelGroup.rotation.z - cap.angle;
          });
        }
        if (clockHands.hours.length > 0) {
          updateClock();
        }

        prevTime = time;
        // renderer.render(scene, camera); // OLD
        composer.render(); // NEW: Post-Processing
      }

      init();
    </script>
  </body>
</html>
